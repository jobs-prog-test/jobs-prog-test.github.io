import {
  require_buffer
} from "./chunk-L74RUGM4.js";
import {
  __commonJS,
  __require
} from "./chunk-IYYBMQRV.js";

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e();
      }
    }(function() {
      return function s(a, o, h) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t)
                return t(r, true);
              if (l)
                return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof __require && __require, e = 0; e < h.length; e++)
          u(h[e]);
        return u;
      }({ 1: [function(e, t, r) {
        "use strict";
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
            f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
          if (e2.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
            t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        "use strict";
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        "use strict";
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        "use strict";
        var n = e("./utils");
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++)
              e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          }(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        "use strict";
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++)
            n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
            return 63 & (e3 || 0);
          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2)
            this.push({ data: function(e3) {
              return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
            }(e2), meta: { percent: 100 } });
          else
            for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
            this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2))
            return false;
          for (var r2 = 0; r2 < t2.length; r2++)
            try {
              t2[r2].error(e2);
            } catch (e3) {
            }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
            e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        "use strict";
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
          try {
            e2.forEach(function(e3, t3) {
              h++;
              var r2 = function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3)
                  throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n))
            return new n();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this)
              "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        "use strict";
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32)
              for (var n2 = 0; n2 < r2.length; n2++)
                t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        "use strict";
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e2, t2);
          if ("number" == typeof e2)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc)
            return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        "use strict";
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d(e2, o2, s2);
          this.files[e2] = h2;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files)
            n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length)
            return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2)
            return this;
          if (h(r2))
            return this.filter(function(e3, t3) {
              return t3.dir && r2.test(e3);
            });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
            delete this.files[r2];
          else
            for (var t2 = this.filter(function(e3, t3) {
              return t3.name.slice(0, r2.length) === r2;
            }), n2 = 0; n2 < t2.length; n2++)
              delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
              throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        "use strict";
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++)
            e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
            if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
              return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        "use strict";
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
            r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        "use strict";
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        "use strict";
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        "use strict";
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2)
            return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        "use strict";
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        "use strict";
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        "use strict";
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2])
            for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
              this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        "use strict";
        var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream)
          try {
            o = e("../nodejs/NodejsStreamOutputAdapter");
          } catch (e2) {
          }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h.transformTo(e4, t3);
                  }
                }(s2, function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++)
                    s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                        i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                }(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        "use strict";
        for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
          u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
              55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e2);
        }, s.utf8decode = function(e2) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; )
              if ((n2 = e3[t2++]) < 128)
                a2[r2++] = n2;
              else if (4 < (i2 = u[n2]))
                a2[r2++] = 65533, t2 += i2 - 1;
              else {
                for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                  n2 = n2 << 6 | 63 & e3[t2++], i2--;
                1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
              }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else
              t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
              r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        "use strict";
        var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2)
            return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; )
            "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
            t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        }() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
            for (; 1 < t2; )
              try {
                return i.stringifyByChunk(e2, r2, t2);
              } catch (e3) {
                t2 = Math.floor(t2 / 2);
              }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++)
            t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2)
            return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()])
            throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++)
            n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++)
            for (t2 in arguments[e2])
              Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
            e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++)
            t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
            (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0)
            throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2)
            this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        "use strict";
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e3) {
            for (var t3 in h)
              if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
                return h[t3];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
            t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2)
              this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2)
              this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        "use strict";
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2)
              throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic)
            return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++)
          n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel)
            r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
              var e3 = t2.document.createElement("script");
              e3.onreadystatechange = function() {
                u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
              }, t2.document.documentElement.appendChild(e3);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
                t3[e3]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        "use strict";
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2)
            throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
            return function() {
              t2.apply(e2, arguments);
            };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2)
            return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
            return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status)
            return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2)
            d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
              e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
            e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this)
            return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2)
            return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; )
            h2(e2[t2], t2);
          return o2;
          function h2(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2))
            return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2)
            return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; )
            a2 = e2[i2], t2.resolve(a2).then(function(e3) {
              n2 || (n2 = true, l.resolve(s2, e3));
            }, function(e3) {
              n2 || (n2 = true, l.reject(s2, e3));
            });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        "use strict";
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        "use strict";
        var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p))
            return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l)
            throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
              throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
              return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        "use strict";
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a))
            return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK)
            throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err)
            throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended)
            return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
              return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2)
                throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2)
                r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray)
            e2.set(t2.subarray(r2, r2 + n2), i2);
          else
            for (var s2 = 0; s2 < n2; s2++)
              e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
            n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
            s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        "use strict";
        var h = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h.Buf8(256), n = 0; n < 256; n++)
          u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
            return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++)
            r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
            55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
            t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; )
            if ((i2 = e2[r2++]) < 128)
              o[n2++] = i2;
            else if (4 < (s2 = u[i2]))
              o[n2++] = 65533, r2 += s2 - 1;
            else {
              for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
                i2 = i2 << 6 | 63 & e2[r2++], s2--;
              1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
            }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
            r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
              ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        "use strict";
        var o = function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        }();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++)
            e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        "use strict";
        var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2))
                  break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
                ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in)
              break;
            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
              for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
                ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
              if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
                for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                  ;
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else
              n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
                ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
                return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return A;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          }(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2)
            return _;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
            return R(e2, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l)
                return A;
              if (0 === e2.lookahead)
                break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
              return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0)
            return e2 ? R(e2, _) : _;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
            return R(e2, 0 === e2.avail_out ? -5 : _);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
            if (2 === n2.wrap)
              e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
            else {
              var a2 = v + (n2.w_bits - 8 << 4) << 8;
              a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
            }
          if (69 === n2.status)
            if (n2.gzhead.extra) {
              for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
                U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
            } else
              n2.status = 73;
          if (73 === n2.status)
            if (n2.gzhead.name) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
            } else
              n2.status = 91;
          if (91 === n2.status)
            if (n2.gzhead.comment) {
              i2 = n2.pending;
              do {
                if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                  s2 = 1;
                  break;
                }
                s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
              } while (0 !== s2);
              n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
            } else
              n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out)
              return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
            return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in)
            return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l)
                    return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l)
                    return A;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                  return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
              return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
              return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
          if (!e2 || !e2.state)
            return _;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
            return _;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
              ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        "use strict";
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e:
            do {
              p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                    C[s++] = 65535 & v;
                  else {
                    if (!(16 & y)) {
                      if (0 == (64 & y)) {
                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                        continue t;
                      }
                      if (32 & y) {
                        r2.mode = 12;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", r2.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                    r:
                      for (; ; ) {
                        if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                          if (0 == (64 & y)) {
                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                            continue r;
                          }
                          e2.msg = "invalid distance code", r2.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (d >>>= y, p -= y, (y = s - a) < k) {
                          if (l < (y = k - y) && r2.sane) {
                            e2.msg = "invalid distance too far back", r2.mode = 30;
                            break e;
                          }
                          if (S = c, (x = 0) === f) {
                            if (x += u - y, y < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          } else if (f < y) {
                            if (x += u + f - y, (y -= f) < w) {
                              for (w -= y; C[s++] = c[x++], --y; )
                                ;
                              if (x = 0, f < w) {
                                for (w -= y = f; C[s++] = c[x++], --y; )
                                  ;
                                x = s - k, S = C;
                              }
                            }
                          } else if (x += f - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                          w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                        } else {
                          for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                            ;
                          w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        "use strict";
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
            return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
          e:
            for (; ; )
              switch (r2.mode) {
                case P:
                  if (0 === r2.wrap) {
                    r2.mode = 13;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & r2.wrap && 35615 === u2) {
                    E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                    break;
                  }
                  if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", r2.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                    r2.wbits = k;
                  else if (k > r2.wbits) {
                    e2.msg = "invalid window size", r2.mode = 30;
                    break;
                  }
                  r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                  break;
                case 2:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.flags = u2, 8 != (255 & r2.flags)) {
                    e2.msg = "unknown compression method", r2.mode = 30;
                    break;
                  }
                  if (57344 & r2.flags) {
                    e2.msg = "unknown header flags set", r2.mode = 30;
                    break;
                  }
                  r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                case 3:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                case 4:
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                case 5:
                  if (1024 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                  } else
                    r2.head && (r2.head.extra = null);
                  r2.mode = 6;
                case 6:
                  if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                    break e;
                  r2.length = 0, r2.mode = 7;
                case 7:
                  if (2048 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.name = null);
                  r2.length = 0, r2.mode = 8;
                case 8:
                  if (4096 & r2.flags) {
                    if (0 === o2)
                      break e;
                    for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                      ;
                    if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                      break e;
                  } else
                    r2.head && (r2.head.comment = null);
                  r2.mode = 9;
                case 9:
                  if (512 & r2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (65535 & r2.check)) {
                      e2.msg = "header crc mismatch", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                  break;
                case 10:
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                case 11:
                  if (0 === r2.havedict)
                    return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                  e2.adler = r2.check = 1, r2.mode = 12;
                case 12:
                  if (5 === t2 || 6 === t2)
                    break e;
                case 13:
                  if (r2.last) {
                    u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r2.mode = 14;
                      break;
                    case 1:
                      if (j(r2), r2.mode = 20, 6 !== t2)
                        break;
                      u2 >>>= 2, l2 -= 2;
                      break e;
                    case 2:
                      r2.mode = 17;
                      break;
                    case 3:
                      e2.msg = "invalid block type", r2.mode = 30;
                  }
                  u2 >>>= 2, l2 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", r2.mode = 30;
                    break;
                  }
                  if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                    break e;
                case 15:
                  r2.mode = 16;
                case 16:
                  if (d = r2.length) {
                    if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                    break;
                  }
                  r2.mode = 12;
                  break;
                case 17:
                  for (; l2 < 14; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                    e2.msg = "too many length or distance symbols", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 18;
                case 18:
                  for (; r2.have < r2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                  }
                  for (; r2.have < 19; )
                    r2.lens[A[r2.have++]] = 0;
                  if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid code lengths set", r2.mode = 30;
                    break;
                  }
                  r2.have = 0, r2.mode = 19;
                case 19:
                  for (; r2.have < r2.nlen + r2.ndist; ) {
                    for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (b < 16)
                      u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                    else {
                      if (16 === b) {
                        for (z = _ + 2; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                          e2.msg = "invalid bit length repeat", r2.mode = 30;
                          break;
                        }
                        k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                      } else if (17 === b) {
                        for (z = _ + 3; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                      } else {
                        for (z = _ + 7; l2 < z; ) {
                          if (0 === o2)
                            break e;
                          o2--, u2 += n2[s2++] << l2, l2 += 8;
                        }
                        l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                      }
                      if (r2.have + d > r2.nlen + r2.ndist) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r2.lens[r2.have++] = k;
                    }
                  }
                  if (30 === r2.mode)
                    break;
                  if (0 === r2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                    break;
                  }
                  if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                    e2.msg = "invalid literal/lengths set", r2.mode = 30;
                    break;
                  }
                  if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                    e2.msg = "invalid distances set", r2.mode = 30;
                    break;
                  }
                  if (r2.mode = 20, 6 === t2)
                    break e;
                case 20:
                  r2.mode = 21;
                case 21:
                  if (6 <= o2 && 258 <= h2) {
                    e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                    break;
                  }
                  for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                    r2.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r2.back = -1, r2.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break;
                  }
                  r2.extra = 15 & g, r2.mode = 22;
                case 22:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  r2.was = r2.length, r2.mode = 23;
                case 23:
                  for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    u2 >>>= v, l2 -= v, r2.back += v;
                  }
                  if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break;
                  }
                  r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                case 24:
                  if (r2.extra) {
                    for (z = r2.extra; l2 < z; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                  }
                  if (r2.offset > r2.dmax) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  r2.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c2 - h2, r2.offset > d) {
                    if ((d = r2.offset - d) > r2.whave && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break;
                    }
                    p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                  } else
                    m = i2, p = a2 - r2.offset, d = r2.length;
                  for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                    ;
                  0 === r2.length && (r2.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i2[a2++] = r2.length, h2--, r2.mode = 21;
                  break;
                case 27:
                  if (r2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                      e2.msg = "incorrect data check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 28;
                case 28:
                  if (r2.wrap && r2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 !== (4294967295 & r2.total)) {
                      e2.msg = "incorrect length check", r2.mode = 30;
                      break;
                    }
                    l2 = u2 = 0;
                  }
                  r2.mode = 29;
                case 29:
                  x = 1;
                  break e;
                case 30:
                  x = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U;
              }
          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state)
            return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        "use strict";
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++)
            O[b] = 0;
          for (v = 0; v < n; v++)
            O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++)
            ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++)
            if (z <<= 1, (z -= O[b]) < 0)
              return -1;
          if (0 < z && (0 === e2 || 1 !== w))
            return -1;
          for (B[1] = 0, b = 1; b < 15; b++)
            B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++)
            0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
            return 1;
          for (; ; ) {
            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
              ;
            for (h = 1 << b - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
              if (b === w)
                break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
                x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
                return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        "use strict";
        var i = e("../utils/common"), o = 0, h = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; )
            e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
            ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++)
            s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
            e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit)
            for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
              ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
            0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; )
            s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
            G(e2, s2, r2);
          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
            ;
          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++)
              e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
              p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                  s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--)
                for (n3 = e3.bl_count[s3]; 0 !== n3; )
                  u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
            i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
            if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
              if (o2 < u2)
                for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                  ;
              else
                0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
              s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            M(e3), n3 && (U(e3, r3), U(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          }(e2, t2, r2, true);
        }
        r._tr_init = function(e2) {
          q || (function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++)
              for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
                A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
              for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
                E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++)
              for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
                E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
              C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
              if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
                return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return h;
            for (t3 = 32; t3 < u; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return h;
            return o;
          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
              P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          }(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process.nextTick(function() {
                  c(e4);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                  t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h[e4];
            }
            function c(e4) {
              if (u)
                setTimeout(c, 0, e4);
              else {
                var t3 = h[e4];
                if (t3) {
                  u = true;
                  try {
                    !function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/xlsx-populate/lib/externals.js
var require_externals = __commonJS({
  "node_modules/xlsx-populate/lib/externals.js"(exports, module) {
    "use strict";
    var JSZip = require_jszip_min();
    module.exports = {
      /**
       * The Promise library.
       * @type {Promise}
       */
      get Promise() {
        return JSZip.external.Promise;
      },
      set Promise(Promise2) {
        JSZip.external.Promise = Promise2;
      }
    };
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined2, symIterator = Symbol ? Symbol.iterator : undefined2, symToStringTag = Symbol ? Symbol.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/xlsx-populate/lib/regexify.js
var require_regexify = __commonJS({
  "node_modules/xlsx-populate/lib/regexify.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    module.exports = (pattern) => {
      if (typeof pattern === "string") {
        pattern = new RegExp(_.escapeRegExp(pattern), "igm");
      }
      pattern.lastIndex = 0;
      return pattern;
    };
  }
});

// node_modules/xlsx-populate/lib/blank.js
var require_blank = __commonJS({
  "node_modules/xlsx-populate/lib/blank.js"(exports, module) {
    "use strict";
    module.exports = () => Buffer.from("UEsDBBQAAAAIAAAAIQC1VTAj7AAAAEwCAAALAAAAX3JlbHMvLnJlbHONks1OwzAMgO9IvEPk++puSAihpbsgpN0QKg9gEvdHbeMoCdC9PeGAoNIYPcaxP3+2vD/M06jeOcRenIZtUYJiZ8T2rtXwUj9u7kDFRM7SKI41nDjCobq+2j/zSCkXxa73UWWKixq6lPw9YjQdTxQL8ezyTyNhopSfoUVPZqCWcVeWtxh+M6BaMNXRaghHewOqPnlew5am6Q0/iHmb2KUzLZDnxM6y3fiQ60Pq8zSqptBy0mDFPOVwRPK+yGjA80a79UZ/T4sTJ7KUCI0EvuzzlXFJaLte6P8VLTN+bOYRPyQMryLDtwsubqD6BFBLAwQUAAAACAAAACEA3kEW2XsBAAARAwAAEAAAAGRvY1Byb3BzL2FwcC54bWydkkFP4zAQhe9I/IfId+oElhWqHCNUQBwWbaUWOBtn0lg4tuUZopZfj5OqIV32xO3NzNPLlxmL621rsw4iGu9KVsxyloHTvjJuU7Kn9f3ZFcuQlKuU9Q5KtgNk1/L0RCyjDxDJAGYpwmHJGqIw5xx1A63CWRq7NKl9bBWlMm64r2uj4dbr9xYc8fM8/81hS+AqqM7CGMj2ifOOfhpaed3z4fN6F1KeFDchWKMVpb+Uj0ZHj76m7G6rwQo+HYoUtAL9Hg3tZC74tBQrrSwsUrCslUUQ/KshHkD1S1sqE1GKjuYdaPIxQ/OR1nbOsleF0OOUrFPRKEdsb9sXg7YBKcoXH9+wASAUfGwOcuqdavNLFoMhiWMjH0GSPkZcG7KAf+ulivQf4mJKPDCwCeOq5yu+8R2+9E/2wrdBubRAPqo/xr3hU1j7W0VwWOdxU6waFaFKFxjXPTbEQ+KKtvcvGuU2UB083wf98Z/3L1wWl7P8Is+Hmx96gn+9ZfkJUEsDBBQAAAAIAOehdkc+qGWw1QAAAG0BAAARAAAAZG9jUHJvcHMvY29yZS54bWxtkE1Lw0AQhu9C/0PYezKJBZGQpDdPCkIVvA67Y7qY/WBnNO2/7zZoFOxxeJ95mHm73dFNxRcltsH3qqlqVZDXwVg/9ur15aG8VwULeoNT8NSrE7HaDZubTsdWh0TPKURKYomLbPLc6tirg0hsAVgfyCFXmfA5fA/JoeQxjRBRf+BIcFvXd+BI0KAgXIRlXI3qW2n0qoyfaVoERgNN5MgLQ1M18MsKJcdXF5bkD+msnCJdRX/ClT6yXcF5nqt5u6D5/gbenh73y6ul9ZeuNKmhg38FDWdQSwMEFAAAAAAA2aF2RwAAAAAAAAAAAAAAAAkAAAB4bC9fcmVscy9QSwMEFAAAAAgAAAAhAI2H2nDaAAAALQIAABoAAAB4bC9fcmVscy93b3JrYm9vay54bWwucmVsc62R3YrCMBCF7xf2HcLcb9NWWGQx9UYWeiv1AUI6/cE2CZlZtW9vXMEfEPHCq+FMmO+cySyWh3EQOwzUO6sgS1IQaI2re9sq2FS/X3MQxNrWenAWFUxIsCw+PxZrHDTHIep6TyJSLCnomP2PlGQ6HDUlzqONL40Lo+YoQyu9NlvdoszT9FuGWwYUd0xR1gpCWc9AVJPHV9iuaXqDK2f+RrT8wEIST0NcQFQ6tMgKzjqJHJCP7fN32nOcxav7vzw3s2cZsndm2LuwpQ6RrzkurfhBp3IJI++OXBwBUEsDBBQAAAAIAAAAIQDeI/LTbgIAALEFAAANAAAAeGwvc3R5bGVzLnhtbKWUXWvbMBSG7wf7D0L3rmw3zpJguyxNDYVuDJrBbhVbTkT1YSSlSzb233tkO7FDxzbWK53z6ug5rz7s9OYgBXpmxnKtMhxdhRgxVeqKq22Gv66LYIaRdVRVVGjFMnxkFt/k79+l1h0Fe9wx5hAglM3wzrlmQYgtd0xSe6UbpmCm1kZSB6nZEtsYRivrF0lB4jCcEkm5wh1hIct/gUhqnvZNUGrZUMc3XHB3bFkYyXJxv1Xa0I0Aq4doQssTu01e4SUvjba6dleAI7quecleu5yTOQFSntZaOYtKvVcOzgrQHrp4Uvq7KvyUF7uqPLU/0DMVoESY5GmphTbIQVfmi0BRVLKu4pYKvjHcizWVXBw7OfZCa7Svkxy25kXSdWgHC4u4EGdXMe6EPIXTccyoAhLUx+tjA+0VXGSHaev+Ur019BjFyWhBO0DfjTYVPJzhPE5SngpWO1hg+HbnR6cb4iedg1PO04rTrVZUeORpRR8AtmRCPPrH9a2+YB9qpPaykO6+yjA8U7/7UwiG+rDDdInnj2kd+81YdKgv+Wd02+iCflaRv+8Mf/YPWQwItNlz4bj6jWFgVofBazvr/Mu+7AKMitV0L9z6PJnhIf7EKr6X8bnqC3/Wrq8a4gd/U9HU92AH92BdO6K94Rn+ebf8MF/dFXEwC5ezYHLNkmCeLFdBMrldrlbFPIzD21+jD+0Nn1n7O4BLiSYLK6DK9JvtzT8OWoZHSWe/PT+wPfY+j6fhxyQKg+I6jILJlM6C2fQ6CYokilfTyfIuKZKR9+T/vEchiaLBfLJwXDLBFbu0vx6rcEmQ/mET5HQTZPjX5i9QSwMEFAAAAAAA2aF2RwAAAAAAAAAAAAAAAAkAAAB4bC90aGVtZS9QSwMEFAAAAAgAAAAhAIuCblj1BQAAjhoAABMAAAB4bC90aGVtZS90aGVtZTEueG1s7VlPjxs1FL8j8R2suafzfyZZNVslk6SF7rZVd1vUozNxMm4842js7G5UVULtEQkJURAXJG4cEFCplbiUT7NQBEXqV8DjyR9P4tCFbqWCmkjJ+Pn3nn9+7/nZM3Px0klKwBHKGaZZ07AvWAZAWUwHOBs1jVuHvVrdAIzDbAAJzVDTmCFmXNp9/72LcIcnKEVA6GdsBzaNhPPJjmmyWIghu0AnKBN9Q5qnkItmPjIHOTwWdlNiOpYVmCnEmQEymAqz14dDHCNwWJg0dhfGu0T8ZJwVgpjkB7EcUdWQ2MHYLv7YjEUkB0eQNA0xzoAeH6ITbgACGRcdTcOSH8PcvWgulQjfoqvo9eRnrjdXGIwdqZeP+ktFz/O9oLW075T2N3HdsBt0g6U9CYBxLGZqb2D9dqPd8edYBVReamx3wo5rV/CKfXcD3/KLbwXvrvDeBr7Xi1Y+VEDlpa/xSehEXgXvr/DBBj60Wh0vrOAlKCE4G2+gLT9wo8Vsl5AhJVe08Ibv9UJnDl+hTCW7Sv2Mb8u1FN6leU8AZHAhxxngswkawljgIkhwP8dgD48SkXgTmFEmxJZj9SxX/BZfT15Jj8AdBBXtUhSzDVHBB7A4xxPeND4UVg0F8vLZ9y+fPQEvnz0+ffD09MFPpw8fnj74UaN4BWYjVfHFt5/9+fXH4I8n37x49IUez1T8rz988svPn+uBXAU+//Lxb08fP//q09+/e6SBt3LYV+GHOEUMXEPH4CZNxdw0A6B+/s80DhOIKxowEUgNsMuTCvDaDBIdro2qzrudiyKhA16e3q1wPUjyKcca4NUkrQD3KSVtmmunc7UYS53ONBvpB8+nKu4mhEe6saO10HanE5HtWGcySlCF5g0iog1HKEMcFH10jJBG7Q7GFb/u4zinjA45uINBG2KtSw5xn+uVruBUxGWmIyhCXfHN/m3QpkRnvoOOqkixICDRmUSk4sbLcMphqmUMU6Ii9yBPdCQPZnlccTjjItIjRCjoDhBjOp3r+axC96ooLvqw75NZWkXmHI91yD1IqYrs0HGUwHSi5YyzRMV+wMYiRSG4QbmWBK2ukKIt4gCzreG+jVEl3K9e1rdEXdUnSNEzzXVLAtHqepyRIUTSuLlWzVOcvbK0rxV1/11R1xf1Vo61S2u9lG/D/QcLeAdOsxtIrBkN9F39fle///f1e9taPv+qvSrUZqmonN3TrUf3ISbkgM8I2mOyxDMxvUFPCGVDKi3vFCaJuJwPV8GNciivQU75R5gnBwmciGFsOcKIzU2PGJhQJjYJY6vtooNM0306KKW2vbg5FQqQr+Rik1nIxZbES2kQru7CluZla8RUAr40enYSymBVEq6GROiejYRtnReLhoZF3f47FqYSFbH+ACyea/heyUjkGyRoUMSp1F9E99wjvc2Z1Wk7muk1vLM5+QyRrpBQ0q1KQknDBA7QuvicY91YhbRCz9HSCOtvItbmZm0gWbUFjsWac31hJoaTpjEUx0NxmU6EPVbUTUhGWdOI+dzR/6ayTHLGO5AlJUx2lfNPMUc5IDgVua6GgWQrbrYTWm8vuYb19nnOXA8yGg5RzLdIVk3RVxrR9r4muGjQqSB9kAyOQZ9M85tQOMoP7cKBA8z40psDnCvJvfLiWrmaL8XKQ7PVEoVkksD5jqIW8xIur5d0lHlIpuuzqrbnk+mPeuex675aqehQiuaWDSTcWsXe3CavsHL1rHxtrWvUl1L9LvH6G4JCra6n5uqpWVuoneOBQBku2OK35R5x3rvBetaayrlStjbeTtD+XZH5HXFcnRLOJFV0Iu4RosVz5bISSOmiupxwMM1x07hn+S0vcvyoZtX9bs1zPatW91tureX7rt31bavTdu4Lp/Aktf1y7J64nyGz+csXKd94AZMujtkXYpqaVJ6DTaksX8DYzvYXMAALz9wLnF7DbbSDWsNt9Wpep12vNaKgXesEUdjpdSK/3ujdN8CRBHstN/KCbr0W2FFU8wKroF9v1ELPcVpe2Kp3vdb9ua/FzBf/C/dKXrt/AVBLAwQUAAAACAAAACEAfDzuwy4CAACbBAAADwAAAHhsL3dvcmtib29rLnhtbK2UTY+bMBCG75X6H5DvhI9AN0Ehq81H1UjVarXN7l5yccwQ3Bib2qZJVPW/d4CSps1lK+0Fj8344Z13bCa3x1I430EbrmRKgoFPHJBMZVzuUvK0/uiOiGMslRkVSkJKTmDI7fT9u8lB6f1Wqb2DAGlSUlhbJZ5nWAElNQNVgcQ3udIltTjVO89UGmhmCgBbCi/0/Q9eSbkkHSHRr2GoPOcMForVJUjbQTQIalG+KXhlelrJXoMrqd7XlctUWSFiywW3pxZKnJIlq51Umm4Fln0M4p6M4RW65Ewro3I7QNRvkVf1Br4XBF3J00nOBTx3tju0qu5p2XxFEEdQY5cZt5ClBGUIdYC/FnRdzWoucBJEUegTb3puxYN2MshpLewaZfV4TIyHYRg2mVjUnbCgJbUwV9Kih2/kV8ueFwoLdx7hW801mM626QSflCV0ax6oLZxai5TMk82TQX2b7KsqpFFyM1cZbI7CHN1KVTV2FDaCbzcXrtNrif/hO2WNAd5ZZRf/68Z00hj5zOFg/vjaTJ3jC5eZOqRkPMQ7cupnGB/a8IVntkhJOPRvzmufgO8Kiw3wh12nvAt6K7AfHdkegC9NHOCNa8ZV02NseMIx0KssaAn9NkYFw4Y3Q5sYh3HQZsDRfja2HdFrnpIfQeTf3fjjyPWXw9iNRuPQHUXD0J1Hi3AZ3ywXy1n8822PN1KSi2PJCqrtWlO2x//KI+QzaqAprikIdXbPVrXX75r+AlBLAwQUAAAAAADZoXZHAAAAAAAAAAAAAAAADgAAAHhsL3dvcmtzaGVldHMvUEsDBBQAAAAIAAAAIQDmVajjXQEAAIQCAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDEueG1sjZJPawIxEMXvhX6HkLtGbW2ruEpBpB4Kpf/u2ezsbjDJLMlY9dt3dq1S8OJtXibz471JZou9d+IHYrIYMjnsD6SAYLCwocrk1+eq9yRFIh0K7TBAJg+Q5GJ+ezPbYdykGoAEE0LKZE3UTJVKpgavUx8bCNwpMXpNLGOlUhNBF92Qd2o0GDwor22QR8I0XsPAsrQGlmi2HgIdIRGcJvafatukE82ba3Bex8226Rn0DSNy6ywdOqgU3kzXVcCoc8e598N7bU7sTlzgvTURE5bUZ9yf0cvMEzVRTJrPCssJ2rWLCGUmn4dSzWfdxW8Lu/SvFqTzD3BgCAp+Iyna3eeIm7a55qNBO6ouZldd0LcoCij11tE77l7AVjUxZMxZ2hTT4rCEZHiXjOmPxmcTS02a60ZX8KpjZUMSDsru1qMU8YjpasKmqxiZIxH6k6o5OcRW3UlRItJJtG7P/2f+C1BLAwQUAAAACAAAACEApFPFz0EBAAAIBAAAEwAAAFtDb250ZW50X1R5cGVzXS54bWytk89OAjEQxu8mvkPTK9kWPBhjWDj456gc8AFqO8s2dNumUxDe3tmCHgiKBC/b7M583+/bdjqebjrH1pDQBl/zkRhyBl4HY/2i5m/z5+qOM8zKG+WCh5pvAfl0cn01nm8jICO1x5q3Ocd7KVG30CkUIYKnShNSpzK9poWMSi/VAuTNcHgrdfAZfK5y78En40do1Mpl9rShz7skCRxy9rBr7Fk1VzE6q1Wmulx7c0Cp9gRBytKDrY04oAYujxL6ys+Ave6VtiZZA2ymUn5RHXXJjZMfIS3fQ1iK302OpAxNYzWYoFcdSQTGBMpgC5A7J8oqOmX94DS/NKMsy+ifg3z7n8iR6bxh97w8QrE5AcS8dYAXow62vZj+RibhLIWINLkJzqd/jWavriIZQcr2j0SyPh948LvQT70Bc4Qtyz2efAJQSwECFAAUAAAACAAAACEAtVUwI+wAAABMAgAACwAAAAAAAAABAAAAAAAAAAAAX3JlbHMvLnJlbHNQSwECFAAUAAAACAAAACEA3kEW2XsBAAARAwAAEAAAAAAAAAABAAAAAAAVAQAAZG9jUHJvcHMvYXBwLnhtbFBLAQIUABQAAAAIAOehdkc+qGWw1QAAAG0BAAARAAAAAAAAAAEAIAAAAL4CAABkb2NQcm9wcy9jb3JlLnhtbFBLAQIUABQAAAAAANmhdkcAAAAAAAAAAAAAAAAJAAAAAAAAAAAAEAAAAMIDAAB4bC9fcmVscy9QSwECFAAUAAAACAAAACEAjYfacNoAAAAtAgAAGgAAAAAAAAABAAAAAADpAwAAeGwvX3JlbHMvd29ya2Jvb2sueG1sLnJlbHNQSwECFAAUAAAACAAAACEA3iPy024CAACxBQAADQAAAAAAAAABAAAAAAD7BAAAeGwvc3R5bGVzLnhtbFBLAQIUABQAAAAAANmhdkcAAAAAAAAAAAAAAAAJAAAAAAAAAAAAEAAAAJQHAAB4bC90aGVtZS9QSwECFAAUAAAACAAAACEAi4JuWPUFAACOGgAAEwAAAAAAAAABAAAAAAC7BwAAeGwvdGhlbWUvdGhlbWUxLnhtbFBLAQIUABQAAAAIAAAAIQB8PO7DLgIAAJsEAAAPAAAAAAAAAAEAAAAAAOENAAB4bC93b3JrYm9vay54bWxQSwECFAAUAAAAAADZoXZHAAAAAAAAAAAAAAAADgAAAAAAAAAAABAAAAA8EAAAeGwvd29ya3NoZWV0cy9QSwECFAAUAAAACAAAACEA5lWo410BAACEAgAAGAAAAAAAAAABAAAAAABoEAAAeGwvd29ya3NoZWV0cy9zaGVldDEueG1sUEsBAhQAFAAAAAgAAAAhAKRTxc9BAQAACAQAABMAAAAAAAAAAQAAAAAA+xEAAFtDb250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAwADADoAgAAbRMAAAAA", "base64");
  }
});

// node_modules/xlsx-populate/lib/xmlq.js
var require_xmlq = __commonJS({
  "node_modules/xlsx-populate/lib/xmlq.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    module.exports = {
      /**
       * Append a child to the node.
       * @param {{}} node - The parent node.
       * @param {{}} child - The child node.
       * @returns {undefined}
       */
      appendChild(node, child) {
        if (!node.children)
          node.children = [];
        node.children.push(child);
      },
      /**
       * Append a child if one with the given name is not found.
       * @param {{}} node - The parent node.
       * @param {string} name - The child node name.
       * @returns {{}} The child.
       */
      appendChildIfNotFound(node, name) {
        let child = this.findChild(node, name);
        if (!child) {
          child = { name, attributes: {}, children: [] };
          this.appendChild(node, child);
        }
        return child;
      },
      /**
       * Find a child with the given name.
       * @param {{}} node - The parent node.
       * @param {string} name - The name to find.
       * @returns {undefined|{}} The child if found.
       */
      findChild(node, name) {
        return _.find(node.children, { name });
      },
      /**
       * Get an attribute from a child node.
       * @param {{}} node - The parent node.
       * @param {string} name - The name of the child node.
       * @param {string} attribute - The name of the attribute.
       * @returns {undefined|*} The value of the attribute if found.
       */
      getChildAttribute(node, name, attribute) {
        const child = this.findChild(node, name);
        if (child)
          return child.attributes && child.attributes[attribute];
      },
      /**
       * Returns a value indicating whether the node has a child with the given name.
       * @param {{}} node - The parent node.
       * @param {string} name - The name of the child node.
       * @returns {boolean} True if found, false otherwise.
       */
      hasChild(node, name) {
        return _.some(node.children, { name });
      },
      /**
       * Insert the child after the specified node.
       * @param {{}} node - The parent node.
       * @param {{}} child - The child node.
       * @param {{}} after - The node to insert after.
       * @returns {undefined}
       */
      insertAfter(node, child, after) {
        if (!node.children)
          node.children = [];
        const index = node.children.indexOf(after);
        node.children.splice(index + 1, 0, child);
      },
      /**
       * Insert the child before the specified node.
       * @param {{}} node - The parent node.
       * @param {{}} child - The child node.
       * @param {{}} before - The node to insert before.
       * @returns {undefined}
       */
      insertBefore(node, child, before) {
        if (!node.children)
          node.children = [];
        const index = node.children.indexOf(before);
        node.children.splice(index, 0, child);
      },
      /**
       * Insert a child node in the correct order.
       * @param {{}} node - The parent node.
       * @param {{}} child - The child node.
       * @param {Array.<string>} nodeOrder - The order of the node names.
       * @returns {undefined}
       */
      insertInOrder(node, child, nodeOrder) {
        const childIndex = nodeOrder.indexOf(child.name);
        if (node.children && childIndex >= 0) {
          for (let i = childIndex + 1; i < nodeOrder.length; i++) {
            const sibling = this.findChild(node, nodeOrder[i]);
            if (sibling) {
              this.insertBefore(node, child, sibling);
              return;
            }
          }
        }
        this.appendChild(node, child);
      },
      /**
       * Check if the node is empty (no attributes and no children).
       * @param {{}} node - The node.
       * @returns {boolean} True if empty, false otherwise.
       */
      isEmpty(node) {
        return _.isEmpty(node.children) && _.isEmpty(node.attributes);
      },
      /**
       * Remove a child node.
       * @param {{}} node - The parent node.
       * @param {string|{}} child - The child node or name of node.
       * @returns {undefined}
       */
      removeChild(node, child) {
        if (!node.children)
          return;
        if (typeof child === "string") {
          _.remove(node.children, { name: child });
        } else {
          const index = node.children.indexOf(child);
          if (index >= 0)
            node.children.splice(index, 1);
        }
      },
      /**
       * Set/unset the attributes on the node.
       * @param {{}} node - The node.
       * @param {{}} attributes - The attributes to set.
       * @returns {undefined}
       */
      setAttributes(node, attributes) {
        _.forOwn(attributes, (value, attribute) => {
          if (_.isNil(value)) {
            if (node.attributes)
              delete node.attributes[attribute];
          } else {
            if (!node.attributes)
              node.attributes = {};
            node.attributes[attribute] = value;
          }
        });
      },
      /**
       * Set attributes on a child node, creating the child if necessary.
       * @param {{}} node - The parent node.
       * @param {string} name - The name of the child node.
       * @param {{}} attributes - The attributes to set.
       * @returns {{}} The child.
       */
      setChildAttributes(node, name, attributes) {
        let child = this.findChild(node, name);
        _.forOwn(attributes, (value, attribute) => {
          if (_.isNil(value)) {
            if (child && child.attributes)
              delete child.attributes[attribute];
          } else {
            if (!child) {
              child = { name, attributes: {}, children: [] };
              this.appendChild(node, child);
            }
            if (!child.attributes)
              child.attributes = {};
            child.attributes[attribute] = value;
          }
        });
        return child;
      },
      /**
       * Remove the child node if empty.
       * @param {{}} node - The parent node.
       * @param {string|{}} child - The child or name of child node.
       * @returns {undefined}
       */
      removeChildIfEmpty(node, child) {
        if (typeof child === "string")
          child = this.findChild(node, child);
        if (child && this.isEmpty(child))
          this.removeChild(node, child);
      }
    };
  }
});

// node_modules/xlsx-populate/lib/ArgHandler.js
var require_ArgHandler = __commonJS({
  "node_modules/xlsx-populate/lib/ArgHandler.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var ArgHandler = class {
      /**
       * Creates a new instance of ArgHandler.
       * @param {string} name - The method name to use in error messages.
       */
      constructor(name) {
        this._name = name;
        this._cases = [];
      }
      /**
       * Add a case.
       * @param {string|Array.<string>} [types] - The type or types of arguments to match this case.
       * @param {Function} handler - The function to call when this case is matched.
       * @returns {ArgHandler} The handler for chaining.
       */
      case(types, handler) {
        if (arguments.length === 1) {
          handler = types;
          types = [];
        }
        if (!Array.isArray(types))
          types = [types];
        this._cases.push({ types, handler });
        return this;
      }
      /**
       * Handle the method arguments by checking each case in order until one matches and then call its handler.
       * @param {Arguments|Array.<*>} args - The method arguments.
       * @returns {*} The result of the handler.
       * @throws {Error} Throws if no case matches.
       */
      handle(args) {
        for (let i = 0; i < this._cases.length; i++) {
          const c = this._cases[i];
          if (this._argsMatchTypes(args, c.types)) {
            return c.handler.apply(null, args);
          }
        }
        throw new Error(`${this._name}: Invalid arguments.`);
      }
      /**
       * Check if the arguments match the given types.
       * @param {Arguments} args - The arguments.
       * @param {Array.<string>} types - The types.
       * @returns {boolean} True if matches, false otherwise.
       * @throws {Error} Throws if unknown type.
       * @private
       */
      _argsMatchTypes(args, types) {
        if (args.length !== types.length)
          return false;
        return _.every(args, (arg, i) => {
          const type = types[i];
          if (type === "*")
            return true;
          if (type === "nil")
            return _.isNil(arg);
          if (type === "string")
            return typeof arg === "string";
          if (type === "boolean")
            return typeof arg === "boolean";
          if (type === "number")
            return typeof arg === "number";
          if (type === "integer")
            return typeof arg === "number" && _.isInteger(arg);
          if (type === "function")
            return typeof arg === "function";
          if (type === "array")
            return Array.isArray(arg);
          if (type === "date")
            return arg && arg.constructor === Date;
          if (type === "object")
            return arg && arg.constructor === Object;
          if (arg && arg.constructor && arg.constructor.name === type)
            return true;
          throw new Error(`Unknown type: ${type}`);
        });
      }
    };
    module.exports = ArgHandler;
  }
});

// node_modules/xlsx-populate/lib/addressConverter.js
var require_addressConverter = __commonJS({
  "node_modules/xlsx-populate/lib/addressConverter.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var ADDRESS_REGEX = /^(?:'?(.+?)'?!)?(?:(\$)?([A-Z]+)(\$)?(\d+)(?::(\$)?([A-Z]+)(\$)?(\d+))?|(\$)?([A-Z]+):(\$)?([A-Z]+)|(\$)?(\d+):(\$)?(\d+))$/;
    module.exports = {
      /**
       * Convert a column name to a number.
       * @param {string} name - The column name.
       * @returns {number} The number.
       */
      columnNameToNumber(name) {
        if (!name || typeof name !== "string")
          return;
        name = name.toUpperCase();
        let sum = 0;
        for (let i = 0; i < name.length; i++) {
          sum = sum * 26;
          sum = sum + (name[i].charCodeAt(0) - "A".charCodeAt(0) + 1);
        }
        return sum;
      },
      /**
       * Convert a column number to a name.
       * @param {number} number - The column number.
       * @returns {string} The name.
       */
      columnNumberToName(number) {
        let dividend = number;
        let name = "";
        let modulo = 0;
        while (dividend > 0) {
          modulo = (dividend - 1) % 26;
          name = String.fromCharCode("A".charCodeAt(0) + modulo) + name;
          dividend = Math.floor((dividend - modulo) / 26);
        }
        return name;
      },
      /**
       * Convert an address to a reference object.
       * @param {string} address - The address.
       * @returns {{}} The reference object.
       */
      fromAddress(address) {
        const match = address.match(ADDRESS_REGEX);
        if (!match)
          return;
        const ref = {};
        if (match[1])
          ref.sheetName = match[1].replace(/''/g, "'");
        if (match[3] && match[7]) {
          ref.type = "range";
          ref.startColumnAnchored = !!match[2];
          ref.startColumnName = match[3];
          ref.startColumnNumber = this.columnNameToNumber(ref.startColumnName);
          ref.startRowAnchored = !!match[4];
          ref.startRowNumber = parseInt(match[5]);
          ref.endColumnAnchored = !!match[6];
          ref.endColumnName = match[7];
          ref.endColumnNumber = this.columnNameToNumber(ref.endColumnName);
          ref.endRowAnchored = !!match[8];
          ref.endRowNumber = parseInt(match[9]);
        } else if (match[3]) {
          ref.type = "cell";
          ref.columnAnchored = !!match[2];
          ref.columnName = match[3];
          ref.columnNumber = this.columnNameToNumber(ref.columnName);
          ref.rowAnchored = !!match[4];
          ref.rowNumber = parseInt(match[5]);
        } else if (match[11] && match[11] !== match[13]) {
          ref.type = "columnRange";
          ref.startColumnAnchored = !!match[10];
          ref.startColumnName = match[11];
          ref.startColumnNumber = this.columnNameToNumber(ref.startColumnName);
          ref.endColumnAnchored = !!match[12];
          ref.endColumnName = match[13];
          ref.endColumnNumber = this.columnNameToNumber(ref.endColumnName);
        } else if (match[11]) {
          ref.type = "column";
          ref.columnAnchored = !!match[10];
          ref.columnName = match[11];
          ref.columnNumber = this.columnNameToNumber(ref.columnName);
        } else if (match[15] && match[15] !== match[17]) {
          ref.type = "rowRange";
          ref.startRowAnchored = !!match[14];
          ref.startRowNumber = parseInt(match[15]);
          ref.endRowAnchored = !!match[16];
          ref.endRowNumber = parseInt(match[17]);
        } else if (match[15]) {
          ref.type = "row";
          ref.rowAnchored = !!match[14];
          ref.rowNumber = parseInt(match[15]);
        }
        return ref;
      },
      /**
       * Convert a reference object to an address.
       * @param {{}} ref - The reference object.
       * @returns {string} The address.
       */
      toAddress(ref) {
        let a, b;
        const sheetName = ref.sheetName;
        if (ref.type === "cell") {
          a = {
            columnName: ref.columnName,
            columnNumber: ref.columnNumber,
            columnAnchored: ref.columnAnchored,
            rowNumber: ref.rowNumber,
            rowAnchored: ref.rowAnchored
          };
        } else if (ref.type === "range") {
          a = {
            columnName: ref.startColumnName,
            columnNumber: ref.startColumnNumber,
            columnAnchored: ref.startColumnAnchored,
            rowNumber: ref.startRowNumber,
            rowAnchored: ref.startRowAnchored
          };
          b = {
            columnName: ref.endColumnName,
            columnNumber: ref.endColumnNumber,
            columnAnchored: ref.endColumnAnchored,
            rowNumber: ref.endRowNumber,
            rowAnchored: ref.endRowAnchored
          };
        } else if (ref.type === "column") {
          a = b = {
            columnName: ref.columnName,
            columnNumber: ref.columnNumber,
            columnAnchored: ref.columnAnchored
          };
        } else if (ref.type === "row") {
          a = b = {
            rowNumber: ref.rowNumber,
            rowAnchored: ref.rowAnchored
          };
        } else if (ref.type === "columnRange") {
          a = {
            columnName: ref.startColumnName,
            columnNumber: ref.startColumnNumber,
            columnAnchored: ref.startColumnAnchored
          };
          b = {
            columnName: ref.endColumnName,
            columnNumber: ref.endColumnNumber,
            columnAnchored: ref.endColumnAnchored
          };
        } else if (ref.type === "rowRange") {
          a = {
            rowNumber: ref.startRowNumber,
            rowAnchored: ref.startRowAnchored
          };
          b = {
            rowNumber: ref.endRowNumber,
            rowAnchored: ref.endRowAnchored
          };
        }
        let address = "";
        if (sheetName)
          address = `${address}'${sheetName.replace(/'/g, "''")}'!`;
        if (a.columnAnchored)
          address = `${address}$`;
        if (a.columnName)
          address = address + a.columnName;
        else if (a.columnNumber)
          address = address + this.columnNumberToName(a.columnNumber);
        if (a.rowAnchored)
          address = `${address}$`;
        if (a.rowNumber)
          address = address + a.rowNumber;
        if (b) {
          address = `${address}:`;
          if (b.columnAnchored)
            address = `${address}$`;
          if (b.columnName)
            address = address + b.columnName;
          else if (b.columnNumber)
            address = address + this.columnNumberToName(b.columnNumber);
          if (b.rowAnchored)
            address = `${address}$`;
          if (b.rowNumber)
            address = address + b.rowNumber;
        }
        return address;
      }
    };
  }
});

// node_modules/xlsx-populate/lib/dateConverter.js
var require_dateConverter = __commonJS({
  "node_modules/xlsx-populate/lib/dateConverter.js"(exports, module) {
    "use strict";
    var dateBase = new Date(1900, 0, 0);
    var incorrectLeapDate = new Date(1900, 1, 28);
    var millisecondsInDay = 1e3 * 60 * 60 * 24;
    module.exports = {
      /**
       * Convert a date to a number for Excel.
       * @param {Date} date - The date.
       * @returns {number} The number.
       */
      dateToNumber(date) {
        const dateOnly = new Date(date.getTime());
        dateOnly.setHours(0, 0, 0, 0);
        let number = Math.round((dateOnly - dateBase) / millisecondsInDay);
        number += (date - dateOnly) / millisecondsInDay;
        if (date > incorrectLeapDate)
          number += 1;
        return number;
      },
      /**
       * Convert a number to a date.
       * @param {number} number - The number.
       * @returns {Date} The date.
       */
      numberToDate(number) {
        if (number > this.dateToNumber(incorrectLeapDate))
          number--;
        const fullDays = Math.floor(number);
        const partialMilliseconds = Math.round((number - fullDays) * millisecondsInDay);
        const date = new Date(dateBase.getTime() + partialMilliseconds);
        date.setDate(date.getDate() + fullDays);
        return date;
      }
    };
  }
});

// node_modules/xlsx-populate/lib/FormulaError.js
var require_FormulaError = __commonJS({
  "node_modules/xlsx-populate/lib/FormulaError.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var FormulaError = class {
      // /**
      //  * Creates a new instance of Formula Error.
      //  * @param {string} error - The error code.
      //  */
      constructor(error) {
        this._error = error;
      }
      /**
       * Get the error code.
       * @returns {string} The error code.
       */
      error() {
        return this._error;
      }
    };
    FormulaError.DIV0 = new FormulaError("#DIV/0!");
    FormulaError.NA = new FormulaError("#N/A");
    FormulaError.NAME = new FormulaError("#NAME?");
    FormulaError.NULL = new FormulaError("#NULL!");
    FormulaError.NUM = new FormulaError("#NUM!");
    FormulaError.REF = new FormulaError("#REF!");
    FormulaError.VALUE = new FormulaError("#VALUE!");
    FormulaError.getError = (error) => {
      return _.find(FormulaError, (value) => {
        return value instanceof FormulaError && value.error() === error;
      }) || new FormulaError(error);
    };
    module.exports = FormulaError;
  }
});

// node_modules/xlsx-populate/lib/colorIndexes.js
var require_colorIndexes = __commonJS({
  "node_modules/xlsx-populate/lib/colorIndexes.js"(exports, module) {
    "use strict";
    module.exports = [
      "000000",
      "FFFFFF",
      "FF0000",
      "00FF00",
      "0000FF",
      "FFFF00",
      "FF00FF",
      "00FFFF",
      "000000",
      "FFFFFF",
      "FF0000",
      "00FF00",
      "0000FF",
      "FFFF00",
      "FF00FF",
      "00FFFF",
      "800000",
      "008000",
      "000080",
      "808000",
      "800080",
      "008080",
      "C0C0C0",
      "808080",
      "9999FF",
      "993366",
      "FFFFCC",
      "CCFFFF",
      "660066",
      "FF8080",
      "0066CC",
      "CCCCFF",
      "000080",
      "FF00FF",
      "FFFF00",
      "00FFFF",
      "800080",
      "800000",
      "008080",
      "0000FF",
      "00CCFF",
      "CCFFFF",
      "CCFFCC",
      "FFFF99",
      "99CCFF",
      "FF99CC",
      "CC99FF",
      "FFCC99",
      "3366FF",
      "33CCCC",
      "99CC00",
      "FFCC00",
      "FF9900",
      "FF6600",
      "666699",
      "969696",
      "003366",
      "339966",
      "003300",
      "333300",
      "993300",
      "993366",
      "333399",
      "333333",
      "System Foreground",
      "System Background"
    ];
  }
});

// node_modules/xlsx-populate/lib/Style.js
var require_Style = __commonJS({
  "node_modules/xlsx-populate/lib/Style.js"(exports, module) {
    "use strict";
    var ArgHandler = require_ArgHandler();
    var _ = require_lodash();
    var xmlq = require_xmlq();
    var colorIndexes = require_colorIndexes();
    var Style = class {
      /**
       * Creates a new instance of _Style.
       * @constructor
       * @param {StyleSheet} styleSheet - The styleSheet.
       * @param {number} id - The style ID.
       * @param {{}} xfNode - The xf node.
       * @param {{}} fontNode - The font node.
       * @param {{}} fillNode - The fill node.
       * @param {{}} borderNode - The border node.
       */
      constructor(styleSheet, id, xfNode, fontNode, fillNode, borderNode) {
        this._styleSheet = styleSheet;
        this._id = id;
        this._xfNode = xfNode;
        this._fontNode = fontNode;
        this._fillNode = fillNode;
        this._borderNode = borderNode;
      }
      /**
       * Gets the style ID.
       * @returns {number} The ID.
       */
      id() {
        return this._id;
      }
      /**
       * Gets or sets a style.
       * @param {string} name - The style name.
       * @param {*} [value] - The value to set.
       * @returns {*|Style} The value if getting or the style if setting.
       */
      style() {
        return new ArgHandler("_Style.style").case("string", (name) => {
          const getterName = `_get_${name}`;
          if (!this[getterName])
            throw new Error(`_Style.style: '${name}' is not a valid style`);
          return this[getterName]();
        }).case(["string", "*"], (name, value) => {
          const setterName = `_set_${name}`;
          if (!this[setterName])
            throw new Error(`_Style.style: '${name}' is not a valid style`);
          this[setterName](value);
          return this;
        }).handle(arguments);
      }
      _getColor(node, name) {
        const child = xmlq.findChild(node, name);
        if (!child || !child.attributes)
          return;
        const color = {};
        if (child.attributes.hasOwnProperty("rgb"))
          color.rgb = child.attributes.rgb;
        else if (child.attributes.hasOwnProperty("theme"))
          color.theme = child.attributes.theme;
        else if (child.attributes.hasOwnProperty("indexed"))
          color.rgb = colorIndexes[child.attributes.indexed];
        if (child.attributes.hasOwnProperty("tint"))
          color.tint = child.attributes.tint;
        if (_.isEmpty(color))
          return;
        return color;
      }
      _setColor(node, name, color) {
        if (typeof color === "string")
          color = { rgb: color };
        else if (typeof color === "number")
          color = { theme: color };
        xmlq.setChildAttributes(node, name, {
          rgb: color && color.rgb && color.rgb.toUpperCase(),
          indexed: null,
          theme: color && color.theme,
          tint: color && color.tint
        });
        xmlq.removeChildIfEmpty(node, "color");
      }
      _get_bold() {
        return xmlq.hasChild(this._fontNode, "b");
      }
      _set_bold(bold) {
        if (bold)
          xmlq.appendChildIfNotFound(this._fontNode, "b");
        else
          xmlq.removeChild(this._fontNode, "b");
      }
      _get_italic() {
        return xmlq.hasChild(this._fontNode, "i");
      }
      _set_italic(italic) {
        if (italic)
          xmlq.appendChildIfNotFound(this._fontNode, "i");
        else
          xmlq.removeChild(this._fontNode, "i");
      }
      _get_underline() {
        const uNode = xmlq.findChild(this._fontNode, "u");
        return uNode ? uNode.attributes.val || true : false;
      }
      _set_underline(underline) {
        if (underline) {
          const uNode = xmlq.appendChildIfNotFound(this._fontNode, "u");
          const val = typeof underline === "string" ? underline : null;
          xmlq.setAttributes(uNode, { val });
        } else {
          xmlq.removeChild(this._fontNode, "u");
        }
      }
      _get_strikethrough() {
        return xmlq.hasChild(this._fontNode, "strike");
      }
      _set_strikethrough(strikethrough) {
        if (strikethrough)
          xmlq.appendChildIfNotFound(this._fontNode, "strike");
        else
          xmlq.removeChild(this._fontNode, "strike");
      }
      _getFontVerticalAlignment() {
        return xmlq.getChildAttribute(this._fontNode, "vertAlign", "val");
      }
      _setFontVerticalAlignment(alignment) {
        xmlq.setChildAttributes(this._fontNode, "vertAlign", { val: alignment });
        xmlq.removeChildIfEmpty(this._fontNode, "vertAlign");
      }
      _get_subscript() {
        return this._getFontVerticalAlignment() === "subscript";
      }
      _set_subscript(subscript) {
        this._setFontVerticalAlignment(subscript ? "subscript" : null);
      }
      _get_superscript() {
        return this._getFontVerticalAlignment() === "superscript";
      }
      _set_superscript(superscript) {
        this._setFontVerticalAlignment(superscript ? "superscript" : null);
      }
      _get_fontSize() {
        return xmlq.getChildAttribute(this._fontNode, "sz", "val");
      }
      _set_fontSize(size) {
        xmlq.setChildAttributes(this._fontNode, "sz", { val: size });
        xmlq.removeChildIfEmpty(this._fontNode, "sz");
      }
      _get_fontFamily() {
        return xmlq.getChildAttribute(this._fontNode, "name", "val");
      }
      _set_fontFamily(family) {
        xmlq.setChildAttributes(this._fontNode, "name", { val: family });
        xmlq.removeChildIfEmpty(this._fontNode, "name");
      }
      _get_fontGenericFamily() {
        return xmlq.getChildAttribute(this._fontNode, "family", "val");
      }
      _set_fontGenericFamily(genericFamily) {
        xmlq.setChildAttributes(this._fontNode, "family", { val: genericFamily });
        xmlq.removeChildIfEmpty(this._fontNode, "family");
      }
      _get_fontColor() {
        return this._getColor(this._fontNode, "color");
      }
      _set_fontColor(color) {
        this._setColor(this._fontNode, "color", color);
      }
      _get_fontScheme() {
        return xmlq.getChildAttribute(this._fontNode, "scheme", "val");
      }
      _set_fontScheme(scheme) {
        xmlq.setChildAttributes(this._fontNode, "scheme", { val: scheme });
        xmlq.removeChildIfEmpty(this._fontNode, "scheme");
      }
      _get_horizontalAlignment() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "horizontal");
      }
      _set_horizontalAlignment(alignment) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { horizontal: alignment });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_justifyLastLine() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "justifyLastLine") === 1;
      }
      _set_justifyLastLine(justifyLastLine) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { justifyLastLine: justifyLastLine ? 1 : null });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_indent() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "indent");
      }
      _set_indent(indent) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { indent });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_verticalAlignment() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "vertical");
      }
      _set_verticalAlignment(alignment) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { vertical: alignment });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_wrapText() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "wrapText") === 1;
      }
      _set_wrapText(wrapText) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { wrapText: wrapText ? 1 : null });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_shrinkToFit() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "shrinkToFit") === 1;
      }
      _set_shrinkToFit(shrinkToFit) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { shrinkToFit: shrinkToFit ? 1 : null });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_textDirection() {
        const readingOrder = xmlq.getChildAttribute(this._xfNode, "alignment", "readingOrder");
        if (readingOrder === 1)
          return "left-to-right";
        if (readingOrder === 2)
          return "right-to-left";
        return readingOrder;
      }
      _set_textDirection(textDirection) {
        let readingOrder;
        if (textDirection === "left-to-right")
          readingOrder = 1;
        else if (textDirection === "right-to-left")
          readingOrder = 2;
        xmlq.setChildAttributes(this._xfNode, "alignment", { readingOrder });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _getTextRotation() {
        return xmlq.getChildAttribute(this._xfNode, "alignment", "textRotation");
      }
      _setTextRotation(textRotation) {
        xmlq.setChildAttributes(this._xfNode, "alignment", { textRotation });
        xmlq.removeChildIfEmpty(this._xfNode, "alignment");
      }
      _get_textRotation() {
        let textRotation = this._getTextRotation();
        if (textRotation > 90)
          textRotation = 90 - textRotation;
        return textRotation;
      }
      _set_textRotation(textRotation) {
        if (textRotation < 0)
          textRotation = 90 - textRotation;
        this._setTextRotation(textRotation);
      }
      _get_angleTextCounterclockwise() {
        return this._getTextRotation() === 45;
      }
      _set_angleTextCounterclockwise(value) {
        this._setTextRotation(value ? 45 : null);
      }
      _get_angleTextClockwise() {
        return this._getTextRotation() === 135;
      }
      _set_angleTextClockwise(value) {
        this._setTextRotation(value ? 135 : null);
      }
      _get_rotateTextUp() {
        return this._getTextRotation() === 90;
      }
      _set_rotateTextUp(value) {
        this._setTextRotation(value ? 90 : null);
      }
      _get_rotateTextDown() {
        return this._getTextRotation() === 180;
      }
      _set_rotateTextDown(value) {
        this._setTextRotation(value ? 180 : null);
      }
      _get_verticalText() {
        return this._getTextRotation() === 255;
      }
      _set_verticalText(value) {
        this._setTextRotation(value ? 255 : null);
      }
      _get_fill() {
        const patternFillNode = xmlq.findChild(this._fillNode, "patternFill");
        const gradientFillNode = xmlq.findChild(this._fillNode, "gradientFill");
        const patternType = patternFillNode && patternFillNode.attributes.patternType;
        if (patternType === "solid") {
          return {
            type: "solid",
            color: this._getColor(patternFillNode, "fgColor")
          };
        }
        if (patternType) {
          return {
            type: "pattern",
            pattern: patternType,
            foreground: this._getColor(patternFillNode, "fgColor"),
            background: this._getColor(patternFillNode, "bgColor")
          };
        }
        if (gradientFillNode) {
          const gradientType = gradientFillNode.attributes.type || "linear";
          const fill = {
            type: "gradient",
            gradientType,
            stops: _.map(gradientFillNode.children, (stop) => ({
              position: stop.attributes.position,
              color: this._getColor(stop, "color")
            }))
          };
          if (gradientType === "linear") {
            fill.angle = gradientFillNode.attributes.degree;
          } else {
            fill.left = gradientFillNode.attributes.left;
            fill.right = gradientFillNode.attributes.right;
            fill.top = gradientFillNode.attributes.top;
            fill.bottom = gradientFillNode.attributes.bottom;
          }
          return fill;
        }
      }
      _set_fill(fill) {
        this._fillNode.children = [];
        if (_.isNil(fill))
          return;
        if (fill.type === "pattern") {
          const patternFill2 = {
            name: "patternFill",
            attributes: { patternType: fill.pattern },
            children: []
          };
          this._fillNode.children.push(patternFill2);
          this._setColor(patternFill2, "fgColor", fill.foreground);
          this._setColor(patternFill2, "bgColor", fill.background);
          return;
        }
        if (fill.type === "gradient") {
          const gradientFill = { name: "gradientFill", attributes: {}, children: [] };
          this._fillNode.children.push(gradientFill);
          xmlq.setAttributes(gradientFill, {
            type: fill.gradientType === "path" ? "path" : void 0,
            left: fill.left,
            right: fill.right,
            top: fill.top,
            bottom: fill.bottom,
            degree: fill.angle
          });
          _.forEach(fill.stops, (fillStop, i) => {
            const stop = {
              name: "stop",
              attributes: { position: fillStop.position },
              children: []
            };
            gradientFill.children.push(stop);
            this._setColor(stop, "color", fillStop.color);
          });
          return;
        }
        if (!_.isObject(fill))
          fill = { type: "solid", color: fill };
        else if (fill.hasOwnProperty("rgb") || fill.hasOwnProperty("theme"))
          fill = { color: fill };
        const patternFill = {
          name: "patternFill",
          attributes: { patternType: "solid" }
        };
        this._fillNode.children.push(patternFill);
        this._setColor(patternFill, "fgColor", fill.color);
      }
      _getBorder() {
        const result = {};
        ["left", "right", "top", "bottom", "diagonal"].forEach((side) => {
          const sideNode = xmlq.findChild(this._borderNode, side);
          const sideResult = {};
          const style = xmlq.getChildAttribute(this._borderNode, side, "style");
          if (style)
            sideResult.style = style;
          const color = this._getColor(sideNode, "color");
          if (color)
            sideResult.color = color;
          if (side === "diagonal") {
            const up = this._borderNode.attributes.diagonalUp;
            const down = this._borderNode.attributes.diagonalDown;
            let direction;
            if (up && down)
              direction = "both";
            else if (up)
              direction = "up";
            else if (down)
              direction = "down";
            if (direction)
              sideResult.direction = direction;
          }
          if (!_.isEmpty(sideResult))
            result[side] = sideResult;
        });
        return result;
      }
      _setBorder(settings) {
        _.forOwn(settings, (setting, side) => {
          if (typeof setting === "boolean") {
            setting = { style: setting ? "thin" : null };
          } else if (typeof setting === "string") {
            setting = { style: setting };
          } else if (setting === null || setting === void 0) {
            setting = { style: null, color: null, direction: null };
          }
          if (setting.hasOwnProperty("style")) {
            xmlq.setChildAttributes(this._borderNode, side, { style: setting.style });
          }
          if (setting.hasOwnProperty("color")) {
            const sideNode = xmlq.findChild(this._borderNode, side);
            this._setColor(sideNode, "color", setting.color);
          }
          if (side === "diagonal") {
            xmlq.setAttributes(this._borderNode, {
              diagonalUp: setting.direction === "up" || setting.direction === "both" ? 1 : null,
              diagonalDown: setting.direction === "down" || setting.direction === "both" ? 1 : null
            });
          }
        });
      }
      _get_border() {
        return this._getBorder();
      }
      _set_border(settings) {
        if (_.isObject(settings) && !settings.hasOwnProperty("style") && !settings.hasOwnProperty("color")) {
          settings = _.defaults(settings, {
            left: null,
            right: null,
            top: null,
            bottom: null,
            diagonal: null
          });
          this._setBorder(settings);
        } else {
          this._setBorder({
            left: settings,
            right: settings,
            top: settings,
            bottom: settings
          });
        }
      }
      _get_borderColor() {
        return _.mapValues(this._getBorder(), (value) => value.color);
      }
      _set_borderColor(color) {
        if (_.isObject(color)) {
          this._setBorder(_.mapValues(color, (color2) => ({ color: color2 })));
        } else {
          this._setBorder({
            left: { color },
            right: { color },
            top: { color },
            bottom: { color },
            diagonal: { color }
          });
        }
      }
      _get_borderStyle() {
        return _.mapValues(this._getBorder(), (value) => value.style);
      }
      _set_borderStyle(style) {
        if (_.isObject(style)) {
          this._setBorder(_.mapValues(style, (style2) => ({ style: style2 })));
        } else {
          this._setBorder({
            left: { style },
            right: { style },
            top: { style },
            bottom: { style }
          });
        }
      }
      _get_diagonalBorderDirection() {
        const border = this._getBorder().diagonal;
        return border && border.direction;
      }
      _set_diagonalBorderDirection(direction) {
        this._setBorder({ diagonal: { direction } });
      }
      _get_numberFormat() {
        const numFmtId = this._xfNode.attributes.numFmtId || 0;
        return this._styleSheet.getNumberFormatCode(numFmtId);
      }
      _set_numberFormat(formatCode) {
        this._xfNode.attributes.numFmtId = this._styleSheet.getNumberFormatId(formatCode);
      }
    };
    ["left", "right", "top", "bottom", "diagonal"].forEach((side) => {
      Style.prototype[`_get_${side}Border`] = function() {
        return this._getBorder()[side];
      };
      Style.prototype[`_set_${side}Border`] = function(settings) {
        this._setBorder({ [side]: settings });
      };
      Style.prototype[`_get_${side}BorderColor`] = function() {
        const border = this._getBorder()[side];
        return border && border.color;
      };
      Style.prototype[`_set_${side}BorderColor`] = function(color) {
        this._setBorder({ [side]: { color } });
      };
      Style.prototype[`_get_${side}BorderStyle`] = function() {
        const border = this._getBorder()[side];
        return border && border.style;
      };
      Style.prototype[`_set_${side}BorderStyle`] = function(style) {
        this._setBorder({ [side]: { style } });
      };
    });
    if (!Style.name)
      Style.name = "Style";
    module.exports = Style;
  }
});

// node_modules/xlsx-populate/lib/RichTextFragment.js
var require_RichTextFragment = __commonJS({
  "node_modules/xlsx-populate/lib/RichTextFragment.js"(exports, module) {
    "use strict";
    var ArgHandler = require_ArgHandler();
    var _ = require_lodash();
    var xmlq = require_xmlq();
    var colorIndexes = require_colorIndexes();
    var RichTextFragment = class {
      /**
       * Creates a new instance of RichTextFragment.
       * @constructor
       * @param {string|Object} value - Text value or XML node
       * @param {object|undefined|null} [styles] - Multiple styles.
       * @param {RichText} richText - The rich text instance where this fragment belongs to.
       */
      constructor(value, styles, richText) {
        this._richText = richText;
        if (value.name === "r") {
          this._node = value;
          this._fontNode = xmlq.findChild(this._node, "rPr");
          if (!this._fontNode) {
            this._fontNode = { name: "rPr", attributes: {}, children: [] };
            this._node.children.unshift(this._fontNode);
          }
          this._valueNode = xmlq.findChild(this._node, "t");
        } else {
          this._node = {
            name: "r",
            attributes: {},
            children: [
              { name: "rPr", attributes: {}, children: [] },
              { name: "t", attributes: {}, children: [] }
            ]
          };
          this._fontNode = xmlq.findChild(this._node, "rPr");
          this._valueNode = xmlq.findChild(this._node, "t");
          this.value(value);
          if (styles) {
            this.style(styles);
          }
        }
      }
      /**
       * Gets the value of this part of rich text
       * @return {string} text
       */
      /**
      * Sets the value of this part of rich text
      * @param {string} text - the text to set
      * @return {RichTextFragment} - RichTextFragment
      */
      value() {
        return new ArgHandler("_RichText.value").case(() => {
          return this._valueNode.children[0];
        }).case("string", (value) => {
          value = value.replace(/(?:\r\n|\r|\n)/g, "\r\n");
          const hasLineSeparator = value.indexOf("\r\n") !== -1;
          this._valueNode.children[0] = value;
          if (value.charAt(0) === " ")
            xmlq.setAttributes(this._valueNode, { "xml:space": "preserve" });
          if (this._richText)
            this._richText.removeUnsupportedNodes();
          if (hasLineSeparator) {
            if (this._richText.cell) {
              this._richText.cell.style("wrapText", true);
            }
            xmlq.setAttributes(this._valueNode, { "xml:space": "preserve" });
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Convert the rich text to an XML object.
       * @returns {{}} The XML form.
       * @ignore
       */
      toXml() {
        return this._node;
      }
      /**
       * Gets an individual style.
       * @param {string} name - The name of the style.
       * @returns {*} The style.
       */
      /**
      * Gets multiple styles.
      * @param {Array.<string>} names - The names of the style.
      * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.
      */
      /**
      * Sets an individual style.
      * @param {string} name - The name of the style.
      * @param {*} value - The value to set.
      * @returns {RichTextFragment} This RichTextFragment.
      */
      /**
      * Sets multiple styles.
      * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.
      * @returns {RichTextFragment} This RichTextFragment.
      */
      style() {
        return new ArgHandler("_RichText.style").case("string", (name) => {
          const getterName = `_get_${name}`;
          if (!this[getterName])
            throw new Error(`_RichText.style: '${name}' is not a valid style`);
          return this[getterName]();
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this.style(name);
          });
          return values;
        }).case(["string", "*"], (name, value) => {
          const setterName = `_set_${name}`;
          if (!this[setterName])
            throw new Error(`_RichText.style: '${name}' is not a valid style`);
          return this[setterName](value);
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this.style(name, value);
          }
          return this;
        }).handle(arguments);
      }
      _getColor(node, name) {
        const child = xmlq.findChild(node, name);
        if (!child || !child.attributes)
          return;
        const color = {};
        if (child.attributes.hasOwnProperty("rgb"))
          color.rgb = child.attributes.rgb;
        else if (child.attributes.hasOwnProperty("theme"))
          color.theme = child.attributes.theme;
        else if (child.attributes.hasOwnProperty("indexed"))
          color.rgb = colorIndexes[child.attributes.indexed];
        if (child.attributes.hasOwnProperty("tint"))
          color.tint = child.attributes.tint;
        if (_.isEmpty(color))
          return;
        return color;
      }
      _setColor(node, name, color) {
        if (typeof color === "string")
          color = { rgb: color };
        else if (typeof color === "number")
          color = { theme: color };
        xmlq.setChildAttributes(node, name, {
          rgb: color && color.rgb && color.rgb.toUpperCase(),
          indexed: null,
          theme: color && color.theme,
          tint: color && color.tint
        });
        xmlq.removeChildIfEmpty(node, "color");
      }
      _get_bold() {
        return xmlq.hasChild(this._fontNode, "b");
      }
      _set_bold(bold) {
        if (bold)
          xmlq.appendChildIfNotFound(this._fontNode, "b");
        else
          xmlq.removeChild(this._fontNode, "b");
      }
      _get_italic() {
        return xmlq.hasChild(this._fontNode, "i");
      }
      _set_italic(italic) {
        if (italic)
          xmlq.appendChildIfNotFound(this._fontNode, "i");
        else
          xmlq.removeChild(this._fontNode, "i");
      }
      _get_underline() {
        const uNode = xmlq.findChild(this._fontNode, "u");
        return uNode ? uNode.attributes.val || true : false;
      }
      _set_underline(underline) {
        if (underline) {
          const uNode = xmlq.appendChildIfNotFound(this._fontNode, "u");
          const val = typeof underline === "string" ? underline : null;
          xmlq.setAttributes(uNode, { val });
        } else {
          xmlq.removeChild(this._fontNode, "u");
        }
      }
      _get_strikethrough() {
        return xmlq.hasChild(this._fontNode, "strike");
      }
      _set_strikethrough(strikethrough) {
        if (strikethrough)
          xmlq.appendChildIfNotFound(this._fontNode, "strike");
        else
          xmlq.removeChild(this._fontNode, "strike");
      }
      _getFontVerticalAlignment() {
        return xmlq.getChildAttribute(this._fontNode, "vertAlign", "val");
      }
      _setFontVerticalAlignment(alignment) {
        xmlq.setChildAttributes(this._fontNode, "vertAlign", { val: alignment });
        xmlq.removeChildIfEmpty(this._fontNode, "vertAlign");
      }
      _get_subscript() {
        return this._getFontVerticalAlignment() === "subscript";
      }
      _set_subscript(subscript) {
        this._setFontVerticalAlignment(subscript ? "subscript" : null);
      }
      _get_superscript() {
        return this._getFontVerticalAlignment() === "superscript";
      }
      _set_superscript(superscript) {
        this._setFontVerticalAlignment(superscript ? "superscript" : null);
      }
      _get_fontSize() {
        return xmlq.getChildAttribute(this._fontNode, "sz", "val");
      }
      _set_fontSize(size) {
        xmlq.setChildAttributes(this._fontNode, "sz", { val: size });
        xmlq.removeChildIfEmpty(this._fontNode, "sz");
      }
      _get_fontFamily() {
        return xmlq.getChildAttribute(this._fontNode, "rFont", "val");
      }
      _set_fontFamily(family) {
        xmlq.setChildAttributes(this._fontNode, "rFont", { val: family });
        xmlq.removeChildIfEmpty(this._fontNode, "rFont");
      }
      _get_fontGenericFamily() {
        return xmlq.getChildAttribute(this._fontNode, "family", "val");
      }
      /**
       * @param {number} genericFamily - 1: Serif, 2: Sans Serif, 3: Monospace,
       * @private
       * @return {undefined}
       */
      _set_fontGenericFamily(genericFamily) {
        xmlq.setChildAttributes(this._fontNode, "family", { val: genericFamily });
        xmlq.removeChildIfEmpty(this._fontNode, "family");
      }
      _get_fontColor() {
        return this._getColor(this._fontNode, "color");
      }
      _set_fontColor(color) {
        this._setColor(this._fontNode, "color", color);
      }
      _get_fontScheme() {
        return xmlq.getChildAttribute(this._fontNode, "scheme", "val");
      }
      /**
       * @param {string} scheme - 'minor'|'major'|'none'
       * @private
       * @return {undefined}
       */
      _set_fontScheme(scheme) {
        xmlq.setChildAttributes(this._fontNode, "scheme", { val: scheme });
        xmlq.removeChildIfEmpty(this._fontNode, "scheme");
      }
    };
    if (!RichTextFragment.name)
      RichTextFragment.name = "RichTextFragment";
    module.exports = RichTextFragment;
  }
});

// node_modules/xlsx-populate/lib/RichText.js
var require_RichText = __commonJS({
  "node_modules/xlsx-populate/lib/RichText.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var RichTextFragment = require_RichTextFragment();
    var RichText = class _RichText {
      /**
       * Creates a new instance of RichText. If you get the instance by calling `Cell.value()`,
       * adding a text contains line separator will trigger {@link Cell.style}('wrapText', true), which
       * will make MS Excel show the new line. i.e. In MS Excel, Tap "alt+Enter" in a cell, the cell
       * will set wrap text to true automatically.
       *
       * @param {undefined|null|Object} [node] - The node stored in the shared string
       */
      constructor(node) {
        this._node = [];
        this._cell = null;
        this._remainingNodes = [];
        if (node) {
          for (let i = 0; i < node.length; i++) {
            const fragment = node[i];
            if (fragment.name === "r") {
              this._node.push(new RichTextFragment(fragment, null, this));
            } else {
              this._remainingNodes.push(fragment);
            }
          }
        }
      }
      /**
       * Gets which cell this {@link RichText} instance belongs to.
       * @return {Cell|undefined} The cell this instance belongs to.
       */
      get cell() {
        return this._cell;
      }
      /**
       * Gets the how many rich text fragment this {@link RichText} instance contains
       * @return {number} The number of fragments this {@link RichText} instance has.
       */
      get length() {
        return this._node.length;
      }
      /**
       * Gets concatenated text without styles.
       * @return {string} concatenated text
       */
      text() {
        let text = "";
        for (let i = 0; i < this._node.length; i++) {
          text += this.get(i).value();
        }
        return text;
      }
      /**
       * Gets the instance with cell reference defined.
       * @param {Cell} cell - Cell reference.
       * @return {RichText} The instance with cell reference defined.
       */
      getInstanceWithCellRef(cell) {
        this._cell = cell;
        return this;
      }
      /**
       * Returns a deep copy of this instance.
       * If cell reference is provided, it checks line separators and calls
       * `cell.style('wrapText', true)` when needed.
       * @param {Cell|undefined} [cell] - The cell reference.
       * @return {RichText} A deep copied instance
       */
      copy(cell) {
        const newRichText = new _RichText(_.cloneDeep(this.toXml()));
        if (cell && _.includes(this.text(), "\n")) {
          cell.style("wrapText", true);
        }
        return newRichText;
      }
      /**
       * Gets the ith fragment of this {@link RichText} instance.
       * @param {number} index - The index
       * @return {RichTextFragment} A rich text fragment
       */
      get(index) {
        return this._node[index];
      }
      /**
       * Removes a rich text fragment. This instance will be mutated.
       * @param {number} index - the index of the fragment to remove
       * @return {RichText} the rich text instance
       */
      remove(index) {
        this._node.splice(index, 1);
        this.removeUnsupportedNodes();
        return this;
      }
      /**
       * Adds a rich text fragment to the last or after the given index. This instance will be mutated.
       * @param {string} text - the text
       * @param {{}} [styles] - the styles js object, i.e. {fontSize: 12}
       * @param {number|undefined|null} [index] - the index of the fragment to add
       * @return {RichText} the rich text instance
       */
      add(text, styles, index) {
        if (index === void 0 || index === null) {
          this._node.push(new RichTextFragment(text, styles, this));
        } else {
          this._node.splice(index, 0, new RichTextFragment(text, styles, this));
        }
        this.removeUnsupportedNodes();
        return this;
      }
      /**
       * Clears this rich text
       * @return {RichText} the rich text instance
       */
      clear() {
        this._node = [];
        this._remainingNodes = [];
        this._cell = void 0;
        return this;
      }
      /**
       * Remove all unsupported nodes (phoneticPr, rPh for Japanese language).
       * @return {undefined}
       */
      removeUnsupportedNodes() {
        this._remainingNodes = [];
      }
      /**
       * Convert the rich text to an XML object.
       * @returns {Array.<{}>} The XML form.
       * @ignore
       */
      toXml() {
        const node = [];
        for (let i = 0; i < this._node.length; i++) {
          node.push(this._node[i].toXml());
        }
        return node.concat(this._remainingNodes);
      }
    };
    if (!RichText.name)
      RichText.name = "RichText";
    module.exports = RichText;
  }
});

// node_modules/xlsx-populate/lib/Cell.js
var require_Cell = __commonJS({
  "node_modules/xlsx-populate/lib/Cell.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var ArgHandler = require_ArgHandler();
    var addressConverter = require_addressConverter();
    var dateConverter = require_dateConverter();
    var regexify = require_regexify();
    var xmlq = require_xmlq();
    var FormulaError = require_FormulaError();
    var Style = require_Style();
    var RichText = require_RichText();
    var Cell = class {
      // /**
      //  * Creates a new instance of cell.
      //  * @param {Row} row - The parent row.
      //  * @param {{}} node - The cell node.
      //  */
      constructor(row, node, styleId) {
        this._row = row;
        this._init(node, styleId);
      }
      /* PUBLIC */
      /**
       * Gets a value indicating whether the cell is the active cell in the sheet.
       * @returns {boolean} True if active, false otherwise.
       */
      /**
      * Make the cell the active cell in the sheet.
      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.
      * @returns {Cell} The cell.
      */
      active() {
        return new ArgHandler("Cell.active").case(() => {
          return this.sheet().activeCell() === this;
        }).case("boolean", (active) => {
          if (!active)
            throw new Error("Deactivating cell directly not supported. Activate a different cell instead.");
          this.sheet().activeCell(this);
          return this;
        }).handle(arguments);
      }
      /**
       * Get the address of the column.
       * @param {{}} [opts] - Options
       * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.
       * @param {boolean} [opts.rowAnchored] - Anchor the row.
       * @param {boolean} [opts.columnAnchored] - Anchor the column.
       * @param {boolean} [opts.anchored] - Anchor both the row and the column.
       * @returns {string} The address
       */
      address(opts) {
        return addressConverter.toAddress({
          type: "cell",
          rowNumber: this.rowNumber(),
          columnNumber: this.columnNumber(),
          sheetName: opts && opts.includeSheetName && this.sheet().name(),
          rowAnchored: opts && (opts.rowAnchored || opts.anchored),
          columnAnchored: opts && (opts.columnAnchored || opts.anchored)
        });
      }
      /**
       * Gets the parent column of the cell.
       * @returns {Column} The parent column.
       */
      column() {
        return this.sheet().column(this.columnNumber());
      }
      /**
       * Clears the contents from the cell.
       * @returns {Cell} The cell.
       */
      clear() {
        const hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;
        delete this._value;
        delete this._formulaType;
        delete this._formula;
        delete this._sharedFormulaId;
        delete this._formulaRef;
        if (!_.isNil(hostSharedFormulaId))
          this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);
        return this;
      }
      /**
       * Gets the column name of the cell.
       * @returns {string} The column name.
       */
      columnName() {
        return addressConverter.columnNumberToName(this.columnNumber());
      }
      /**
       * Gets the column number of the cell (1-based).
       * @returns {number} The column number.
       */
      columnNumber() {
        return this._columnNumber;
      }
      /**
       * Find the given pattern in the cell and optionally replace it.
       * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.
       * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.
       * @returns {boolean} A flag indicating if the pattern was found.
       */
      find(pattern, replacement) {
        pattern = regexify(pattern);
        const value = this.value();
        if (typeof value !== "string")
          return false;
        if (_.isNil(replacement)) {
          return pattern.test(value);
        } else {
          const replaced = value.replace(pattern, replacement);
          if (replaced === value)
            return false;
          this.value(replaced);
          return true;
        }
      }
      /**
       * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.
       * @returns {string} The formula in the cell.
       */
      /**
      * Sets the formula in the cell.
      * @param {string} formula - The formula to set.
      * @returns {Cell} The cell.
      */
      formula() {
        return new ArgHandler("Cell.formula").case(() => {
          if (this._formulaType === "shared" && !this._formulaRef)
            return "SHARED";
          return this._formula;
        }).case("nil", () => {
          this.clear();
          return this;
        }).case("string", (formula) => {
          this.clear();
          this._formulaType = "normal";
          this._formula = formula;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the hyperlink attached to the cell.
       * @returns {string|undefined} The hyperlink or undefined if not set.
       */
      /**
      * Set or clear the hyperlink on the cell.
      * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.
      * @returns {Cell} The cell.
      */
      /**
      * Set the hyperlink options on the cell.
      * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.
      * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.
      * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.
      * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.
      * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.
      * @returns {Cell} The cell.
      */
      hyperlink() {
        return new ArgHandler("Cell.hyperlink").case(() => {
          return this.sheet().hyperlink(this.address());
        }).case("string", (hyperlink) => {
          this.sheet().hyperlink(this.address(), hyperlink);
          return this;
        }).case(["object"], (opts) => {
          this.sheet().hyperlink(this.address(), opts);
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the data validation object attached to the cell.
       * @returns {object|undefined} The data validation or undefined if not set.
       */
      /**
      * Set or clear the data validation object of the cell.
      * @param {object|undefined} dataValidation - Object or null to clear.
      * @returns {Cell} The cell.
      */
      dataValidation() {
        return new ArgHandler("Cell.dataValidation").case(() => {
          return this.sheet().dataValidation(this.address());
        }).case("boolean", (obj) => {
          return this.sheet().dataValidation(this.address(), obj);
        }).case("*", (obj) => {
          this.sheet().dataValidation(this.address(), obj);
          return this;
        }).handle(arguments);
      }
      /**
       * Callback used by tap.
       * @callback Cell~tapCallback
       * @param {Cell} cell - The cell
       * @returns {undefined}
       */
      /**
      * Invoke a callback on the cell and return the cell. Useful for method chaining.
      * @param {Cell~tapCallback} callback - The callback function.
      * @returns {Cell} The cell.
      */
      tap(callback) {
        callback(this);
        return this;
      }
      /**
       * Callback used by thru.
       * @callback Cell~thruCallback
       * @param {Cell} cell - The cell
       * @returns {*} The value to return from thru.
       */
      /**
      * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.
      * @param {Cell~thruCallback} callback - The callback function.
      * @returns {*} The return value of the callback.
      */
      thru(callback) {
        return callback(this);
      }
      /**
       * Create a range from this cell and another.
       * @param {Cell|string} cell - The other cell or cell address to range to.
       * @returns {Range} The range.
       */
      rangeTo(cell) {
        return this.sheet().range(this, cell);
      }
      /**
       * Returns a cell with a relative position given the offsets provided.
       * @param {number} rowOffset - The row offset (0 for the current row).
       * @param {number} columnOffset - The column offset (0 for the current column).
       * @returns {Cell} The relative cell.
       */
      relativeCell(rowOffset, columnOffset) {
        const row = rowOffset + this.rowNumber();
        const column = columnOffset + this.columnNumber();
        return this.sheet().cell(row, column);
      }
      /**
       * Gets the parent row of the cell.
       * @returns {Row} The parent row.
       */
      row() {
        return this._row;
      }
      /**
       * Gets the row number of the cell (1-based).
       * @returns {number} The row number.
       */
      rowNumber() {
        return this.row().rowNumber();
      }
      /**
       * Gets the parent sheet.
       * @returns {Sheet} The parent sheet.
       */
      sheet() {
        return this.row().sheet();
      }
      /**
       * Gets an individual style.
       * @param {string} name - The name of the style.
       * @returns {*} The style.
       */
      /**
      * Gets multiple styles.
      * @param {Array.<string>} names - The names of the style.
      * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.
      */
      /**
      * Sets an individual style.
      * @param {string} name - The name of the style.
      * @param {*} value - The value to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets the styles in the range starting with the cell.
      * @param {string} name - The name of the style.
      * @param {Array.<Array.<*>>} - 2D array of values to set.
      * @returns {Range} The range that was set.
      */
      /**
      * Sets multiple styles.
      * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets to a specific style
      * @param {Style} style - Style object given from stylesheet.createStyle
      * @returns {Cell} The cell.
      */
      style() {
        if (!this._style && !(arguments[0] instanceof Style)) {
          this._style = this.workbook().styleSheet().createStyle(this._styleId);
        }
        return new ArgHandler("Cell.style").case("string", (name) => {
          return this._style.style(name);
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this.style(name);
          });
          return values;
        }).case(["string", "array"], (name, values) => {
          const numRows = values.length;
          const numCols = values[0].length;
          const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));
          return range.style(name, values);
        }).case(["string", "*"], (name, value) => {
          this._style.style(name, value);
          return this;
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this.style(name, value);
          }
          return this;
        }).case("Style", (style) => {
          this._style = style;
          this._styleId = style.id();
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the value of the cell.
       * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.
       */
      /**
      * Sets the value of the cell.
      * @param {string|boolean|number|null|undefined|RichText} value - The value to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets the values in the range starting with the cell.
      * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.
      * @returns {Range} The range that was set.
      */
      value() {
        return new ArgHandler("Cell.value").case(() => {
          if (this._value instanceof RichText) {
            return this._value.getInstanceWithCellRef(this);
          }
          return this._value;
        }).case("array", (values) => {
          const numRows = values.length;
          const numCols = values[0].length;
          const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));
          return range.value(values);
        }).case("*", (value) => {
          this.clear();
          if (value instanceof RichText) {
            this._value = value.copy(this);
          } else {
            this._value = value;
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the parent workbook.
       * @returns {Workbook} The parent workbook.
       */
      workbook() {
        return this.row().workbook();
      }
      /**
       * Append horizontal page break after the cell.
       * @returns {Cell} the cell.
       */
      addHorizontalPageBreak() {
        this.row().addPageBreak();
        return this;
      }
      /* INTERNAL */
      /**
       * Gets the formula if a shared formula ref cell.
       * @returns {string|undefined} The formula.
       * @ignore
       */
      getSharedRefFormula() {
        return this._formulaType === "shared" ? this._formulaRef && this._formula : void 0;
      }
      /**
       * Check if this cell uses a given shared a formula ID.
       * @param {number} id - The shared formula ID.
       * @returns {boolean} A flag indicating if shared.
       * @ignore
       */
      sharesFormula(id) {
        return this._formulaType === "shared" && this._sharedFormulaId === id;
      }
      /**
       * Set a shared formula on the cell.
       * @param {number} id - The shared formula index.
       * @param {string} [formula] - The formula (if the reference cell).
       * @param {string} [sharedRef] - The address of the shared range (if the reference cell).
       * @returns {undefined}
       * @ignore
       */
      setSharedFormula(id, formula, sharedRef) {
        this.clear();
        this._formulaType = "shared";
        this._sharedFormulaId = id;
        this._formula = formula;
        this._formulaRef = sharedRef;
      }
      /**
       * Convert the cell to an XML object.
       * @returns {{}} The XML form.
       * @ignore
       */
      toXml() {
        const node = {
          name: "c",
          attributes: this._remainingAttributes || {},
          // Start with any remaining attributes we don't current handle.
          children: []
        };
        node.attributes.r = this.address();
        if (!_.isNil(this._formulaType)) {
          const fNode = {
            name: "f",
            attributes: this._remainingFormulaAttributes || {}
          };
          if (this._formulaType !== "normal")
            fNode.attributes.t = this._formulaType;
          if (!_.isNil(this._formulaRef))
            fNode.attributes.ref = this._formulaRef;
          if (!_.isNil(this._sharedFormulaId))
            fNode.attributes.si = this._sharedFormulaId;
          if (!_.isNil(this._formula))
            fNode.children = [this._formula];
          node.children.push(fNode);
        } else if (!_.isNil(this._value)) {
          let type, text;
          if (typeof this._value === "string") {
            type = "s";
            text = this.workbook().sharedStrings().getIndexForString(this._value);
          } else if (typeof this._value === "boolean") {
            type = "b";
            text = this._value ? 1 : 0;
          } else if (typeof this._value === "number") {
            text = this._value;
          } else if (this._value instanceof Date) {
            text = dateConverter.dateToNumber(this._value);
          } else if (this._value instanceof RichText || typeof this._value === "object" && this._value.constructor.name === "RichText") {
            type = "s";
            text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());
          }
          if (type)
            node.attributes.t = type;
          const vNode = { name: "v", children: [text] };
          node.children.push(vNode);
        }
        if (!_.isNil(this._style)) {
          node.attributes.s = this._style.id();
        } else if (!_.isNil(this._styleId)) {
          node.attributes.s = this._styleId;
        }
        if (this._remainingChildren) {
          node.children = node.children.concat(this._remainingChildren);
        }
        return node;
      }
      /* PRIVATE */
      /**
       * Initialize the cell node.
       * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.
       * @param {number} [styleId] - The style ID for the new cell.
       * @returns {undefined}
       * @private
       */
      _init(nodeOrColumnNumber, styleId) {
        if (_.isObject(nodeOrColumnNumber)) {
          this._parseNode(nodeOrColumnNumber);
        } else {
          this._columnNumber = nodeOrColumnNumber;
          if (!_.isNil(styleId))
            this._styleId = styleId;
        }
      }
      /**
       * Parse the existing node.
       * @param {{}} node - The existing node.
       * @returns {undefined}
       * @private
       */
      _parseNode(node) {
        const ref = addressConverter.fromAddress(node.attributes.r);
        this._columnNumber = ref.columnNumber;
        if (!_.isNil(node.attributes.s))
          this._styleId = node.attributes.s;
        const fNode = xmlq.findChild(node, "f");
        if (fNode) {
          this._formulaType = fNode.attributes.t || "normal";
          this._formulaRef = fNode.attributes.ref;
          this._formula = fNode.children[0];
          this._sharedFormulaId = fNode.attributes.si;
          if (!_.isNil(this._sharedFormulaId)) {
            this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);
          }
          delete fNode.attributes.t;
          delete fNode.attributes.ref;
          delete fNode.attributes.si;
          if (!_.isEmpty(fNode.attributes))
            this._remainingFormulaAttributes = fNode.attributes;
        }
        const type = node.attributes.t;
        if (type === "s") {
          const vNode = xmlq.findChild(node, "v");
          if (vNode) {
            const sharedIndex = vNode.children[0];
            this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);
            if (_.isArray(this._value)) {
              this._value = new RichText(this._value);
            }
          } else {
            this._value = "";
          }
        } else if (type === "str") {
          const vNode = xmlq.findChild(node, "v");
          this._value = vNode && vNode.children[0];
        } else if (type === "inlineStr") {
          const isNode = xmlq.findChild(node, "is");
          if (isNode.children[0].name === "t") {
            const tNode = isNode.children[0];
            this._value = tNode.children[0];
          } else {
            this._value = isNode.children;
          }
        } else if (type === "b") {
          this._value = xmlq.findChild(node, "v").children[0] === 1;
        } else if (type === "e") {
          const error = xmlq.findChild(node, "v").children[0];
          this._value = FormulaError.getError(error);
        } else {
          const vNode = xmlq.findChild(node, "v");
          this._value = vNode && Number(vNode.children[0]);
        }
        delete node.attributes.r;
        delete node.attributes.s;
        delete node.attributes.t;
        if (!_.isEmpty(node.attributes))
          this._remainingAttributes = node.attributes;
        xmlq.removeChild(node, "f");
        xmlq.removeChild(node, "v");
        xmlq.removeChild(node, "is");
        if (!_.isEmpty(node.children))
          this._remainingChildren = node.children;
      }
    };
    module.exports = Cell;
  }
});

// node_modules/xlsx-populate/lib/Row.js
var require_Row = __commonJS({
  "node_modules/xlsx-populate/lib/Row.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var Cell = require_Cell();
    var regexify = require_regexify();
    var ArgHandler = require_ArgHandler();
    var addressConverter = require_addressConverter();
    var Row = class {
      // /**
      //  * Creates a new instance of Row.
      //  * @param {Sheet} sheet - The parent sheet.
      //  * @param {{}} node - The row node.
      //  */
      constructor(sheet, node) {
        this._sheet = sheet;
        this._init(node);
      }
      /* PUBLIC */
      /**
       * Get the address of the row.
       * @param {{}} [opts] - Options
       * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.
       * @param {boolean} [opts.anchored] - Anchor the address.
       * @returns {string} The address
       */
      address(opts) {
        return addressConverter.toAddress({
          type: "row",
          rowNumber: this.rowNumber(),
          sheetName: opts && opts.includeSheetName && this.sheet().name(),
          rowAnchored: opts && opts.anchored
        });
      }
      /**
       * Get a cell in the row.
       * @param {string|number} columnNameOrNumber - The name or number of the column.
       * @returns {Cell} The cell.
       */
      cell(columnNameOrNumber) {
        let columnNumber = columnNameOrNumber;
        if (typeof columnNameOrNumber === "string") {
          columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);
        }
        if (columnNumber < 1)
          throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);
        if (this._cells[columnNumber])
          return this._cells[columnNumber];
        let styleId;
        const rowStyleId = this._node.attributes.s;
        const columnStyleId = this.sheet().existingColumnStyleId(columnNumber);
        if (!_.isNil(rowStyleId))
          styleId = rowStyleId;
        else if (!_.isNil(columnStyleId))
          styleId = columnStyleId;
        const cell = new Cell(this, columnNumber, styleId);
        this._cells[columnNumber] = cell;
        return cell;
      }
      /**
       * Gets the row height.
       * @returns {undefined|number} The height (or undefined).
       */
      /**
      * Sets the row height.
      * @param {number} height - The height of the row.
      * @returns {Row} The row.
      */
      height() {
        return new ArgHandler("Row.height").case(() => {
          return this._node.attributes.customHeight ? this._node.attributes.ht : void 0;
        }).case("number", (height) => {
          this._node.attributes.ht = height;
          this._node.attributes.customHeight = 1;
          return this;
        }).case("nil", () => {
          delete this._node.attributes.ht;
          delete this._node.attributes.customHeight;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a value indicating whether the row is hidden.
       * @returns {boolean} A flag indicating whether the row is hidden.
       */
      /**
      * Sets whether the row is hidden.
      * @param {boolean} hidden - A flag indicating whether to hide the row.
      * @returns {Row} The row.
      */
      hidden() {
        return new ArgHandler("Row.hidden").case(() => {
          return this._node.attributes.hidden === 1;
        }).case("boolean", (hidden) => {
          if (hidden)
            this._node.attributes.hidden = 1;
          else
            delete this._node.attributes.hidden;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the row number.
       * @returns {number} The row number.
       */
      rowNumber() {
        return this._node.attributes.r;
      }
      /**
       * Gets the parent sheet of the row.
       * @returns {Sheet} The parent sheet.
       */
      sheet() {
        return this._sheet;
      }
      /**
       * Gets an individual style.
       * @param {string} name - The name of the style.
       * @returns {*} The style.
       */
      /**
      * Gets multiple styles.
      * @param {Array.<string>} names - The names of the style.
      * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.
      */
      /**
      * Sets an individual style.
      * @param {string} name - The name of the style.
      * @param {*} value - The value to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets multiple styles.
      * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.
      * @returns {Cell} The cell.
         */
      /**
      * Sets to a specific style
      * @param {Style} style - Style object given from stylesheet.createStyle
      * @returns {Cell} The cell.
      */
      style() {
        return new ArgHandler("Row.style").case("string", (name) => {
          this._createStyleIfNeeded();
          return this._style.style(name);
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this.style(name);
          });
          return values;
        }).case(["string", "*"], (name, value) => {
          this._createCellStylesIfNeeded();
          _.forEach(this._cells, (cell) => {
            if (cell)
              cell.style(name, value);
          });
          this._createStyleIfNeeded();
          this._style.style(name, value);
          return this;
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this.style(name, value);
          }
          return this;
        }).case("Style", (style) => {
          this._createCellStylesIfNeeded();
          _.forEach(this._cells, (cell) => {
            if (cell)
              cell.style(style);
          });
          this._style = style;
          this._node.attributes.s = style.id();
          this._node.attributes.customFormat = 1;
          return this;
        }).handle(arguments);
      }
      /**
       * Get the parent workbook.
       * @returns {Workbook} The parent workbook.
       */
      workbook() {
        return this.sheet().workbook();
      }
      /**
       * Append horizontal page break after the row.
       * @returns {Row} the row.
       */
      addPageBreak() {
        this.sheet().horizontalPageBreaks().add(this.rowNumber());
        return this;
      }
      /* INTERNAL */
      /**
       * Clear cells that are using a given shared formula ID.
       * @param {number} sharedFormulaId - The shared formula ID.
       * @returns {undefined}
       * @ignore
       */
      clearCellsUsingSharedFormula(sharedFormulaId) {
        this._cells.forEach((cell) => {
          if (!cell)
            return;
          if (cell.sharesFormula(sharedFormulaId))
            cell.clear();
        });
      }
      /**
       * Find a pattern in the row and optionally replace it.
       * @param {string|RegExp} pattern - The search pattern.
       * @param {string} [replacement] - The replacement text.
       * @returns {Array.<Cell>} The matched cells.
       * @ignore
       */
      find(pattern, replacement) {
        pattern = regexify(pattern);
        const matches = [];
        this._cells.forEach((cell) => {
          if (!cell)
            return;
          if (cell.find(pattern, replacement))
            matches.push(cell);
        });
        return matches;
      }
      /**
       * Check if the row has a cell at the given column number.
       * @param {number} columnNumber - The column number.
       * @returns {boolean} True if a cell exists, false otherwise.
       * @ignore
       */
      hasCell(columnNumber) {
        if (columnNumber < 1)
          throw new RangeError(`Invalid column number ${columnNumber}. Remember that spreadsheets use 1-based indexing.`);
        return !!this._cells[columnNumber];
      }
      /**
       * Check if the column has a style defined.
       * @returns {boolean} True if a style exists, false otherwise.
       * @ignore
       */
      hasStyle() {
        return !_.isNil(this._node.attributes.s);
      }
      /**
       * Returns the nax used column number.
       * @returns {number} The max used column number.
       * @ignore
       */
      minUsedColumnNumber() {
        return _.findIndex(this._cells);
      }
      /**
       * Returns the nax used column number.
       * @returns {number} The max used column number.
       * @ignore
       */
      maxUsedColumnNumber() {
        return this._cells.length - 1;
      }
      /**
       * Convert the row to an object.
       * @returns {{}} The object form.
       * @ignore
       */
      toXml() {
        return this._node;
      }
      /* PRIVATE */
      /**
       * If a column node is already defined that intersects with this row and that column has a style set, we
       * need to make sure that a cell node exists at the intersection so we can style it appropriately.
       * Fetching the cell will force a new cell node to be created with a style matching the column.
       * @returns {undefined}
       * @private
       */
      _createCellStylesIfNeeded() {
        this.sheet().forEachExistingColumnNumber((columnNumber) => {
          if (!_.isNil(this.sheet().existingColumnStyleId(columnNumber)))
            this.cell(columnNumber);
        });
      }
      /**
       * Create a style for this row if it doesn't already exist.
       * @returns {undefined}
       * @private
       */
      _createStyleIfNeeded() {
        if (!this._style) {
          const styleId = this._node.attributes.s;
          this._style = this.workbook().styleSheet().createStyle(styleId);
          this._node.attributes.s = this._style.id();
          this._node.attributes.customFormat = 1;
        }
      }
      /**
       * Initialize the row node.
       * @param {{}} node - The row node.
       * @returns {undefined}
       * @private
       */
      _init(node) {
        this._node = node;
        this._cells = [];
        this._node.children.forEach((cellNode) => {
          const cell = new Cell(this, cellNode);
          this._cells[cell.columnNumber()] = cell;
        });
        this._node.children = this._cells;
      }
    };
    module.exports = Row;
  }
});

// node_modules/xlsx-populate/lib/Column.js
var require_Column = __commonJS({
  "node_modules/xlsx-populate/lib/Column.js"(exports, module) {
    "use strict";
    var ArgHandler = require_ArgHandler();
    var addressConverter = require_addressConverter();
    var defaultColumnWidth = 9.140625;
    var Column = class {
      // /**
      //  * Creates a new Column.
      //  * @param {Sheet} sheet - The parent sheet.
      //  * @param {{}} node - The column node.
      //  * @constructor
      //  * @ignore
      //  * @private
      //  */
      constructor(sheet, node) {
        this._sheet = sheet;
        this._node = node;
      }
      /* PUBLIC */
      /**
       * Get the address of the column.
       * @param {{}} [opts] - Options
       * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.
       * @param {boolean} [opts.anchored] - Anchor the address.
       * @returns {string} The address
       */
      address(opts) {
        return addressConverter.toAddress({
          type: "column",
          columnName: this.columnName(),
          sheetName: opts && opts.includeSheetName && this.sheet().name(),
          columnAnchored: opts && opts.anchored
        });
      }
      /**
       * Get a cell within the column.
       * @param {number} rowNumber - The row number.
       * @returns {Cell} The cell in the column with the given row number.
       */
      cell(rowNumber) {
        return this.sheet().cell(rowNumber, this.columnNumber());
      }
      /**
       * Get the name of the column.
       * @returns {string} The column name.
       */
      columnName() {
        return addressConverter.columnNumberToName(this.columnNumber());
      }
      /**
       * Get the number of the column.
       * @returns {number} The column number.
       */
      columnNumber() {
        return this._node.attributes.min;
      }
      /**
       * Gets a value indicating whether the column is hidden.
       * @returns {boolean} A flag indicating whether the column is hidden.
       */
      /**
      * Sets whether the column is hidden.
      * @param {boolean} hidden - A flag indicating whether to hide the column.
      * @returns {Column} The column.
      */
      hidden() {
        return new ArgHandler("Column.hidden").case(() => {
          return this._node.attributes.hidden === 1;
        }).case("boolean", (hidden) => {
          if (hidden)
            this._node.attributes.hidden = 1;
          else
            delete this._node.attributes.hidden;
          return this;
        }).handle(arguments);
      }
      /**
       * Get the parent sheet.
       * @returns {Sheet} The parent sheet.
       */
      sheet() {
        return this._sheet;
      }
      /**
       * Gets an individual style.
       * @param {string} name - The name of the style.
       * @returns {*} The style.
       */
      /**
      * Gets multiple styles.
      * @param {Array.<string>} names - The names of the style.
      * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.
      */
      /**
      * Sets an individual style.
      * @param {string} name - The name of the style.
      * @param {*} value - The value to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets multiple styles.
      * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.
      * @returns {Cell} The cell.
      */
      /**
      * Sets to a specific style
      * @param {Style} style - Style object given from stylesheet.createStyle
      * @returns {Cell} The cell.
      */
      style() {
        return new ArgHandler("Column.style").case("string", (name) => {
          this._createStyleIfNeeded();
          return this._style.style(name);
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this.style(name);
          });
          return values;
        }).case(["string", "*"], (name, value) => {
          this.sheet().forEachExistingRow((row) => {
            if (row.hasStyle() || row.hasCell(this.columnNumber())) {
              row.cell(this.columnNumber()).style(name, value);
            }
          });
          this._createStyleIfNeeded();
          this._style.style(name, value);
          return this;
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this.style(name, value);
          }
          return this;
        }).case("Style", (style) => {
          this.sheet().forEachExistingRow((row) => {
            if (row.hasStyle() || row.hasCell(this.columnNumber())) {
              row.cell(this.columnNumber()).style(style);
            }
          });
          this._style = style;
          this._node.attributes.style = style.id();
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the width.
       * @returns {undefined|number} The width (or undefined).
       */
      /**
      * Sets the width.
      * @param {number} width - The width of the column.
      * @returns {Column} The column.
      */
      width(width) {
        return new ArgHandler("Column.width").case(() => {
          return this._node.attributes.customWidth ? this._node.attributes.width : void 0;
        }).case("number", (width2) => {
          this._node.attributes.width = width2;
          this._node.attributes.customWidth = 1;
          return this;
        }).case("nil", () => {
          delete this._node.attributes.width;
          delete this._node.attributes.customWidth;
          return this;
        }).handle(arguments);
      }
      /**
       * Get the parent workbook.
       * @returns {Workbook} The parent workbook.
       */
      workbook() {
        return this.sheet().workbook();
      }
      /**
       * Append vertical page break after the column.
       * @returns {Column} the column.
       */
      addPageBreak() {
        this.sheet().verticalPageBreaks().add(this.columnNumber());
        return this;
      }
      /* INTERNAL */
      /**
       * Convert the column to an XML object.
       * @returns {{}} The XML form.
       * @ignore
       */
      toXml() {
        return this._node;
      }
      /* PRIVATE */
      /**
       * Create a style for this column if it doesn't already exist.
       * @returns {undefined}
       * @private
       */
      _createStyleIfNeeded() {
        if (!this._style) {
          const styleId = this._node.attributes.style;
          this._style = this.workbook().styleSheet().createStyle(styleId);
          this._node.attributes.style = this._style.id();
          if (!this.width())
            this.width(defaultColumnWidth);
        }
      }
    };
    module.exports = Column;
  }
});

// node_modules/xlsx-populate/lib/Range.js
var require_Range = __commonJS({
  "node_modules/xlsx-populate/lib/Range.js"(exports, module) {
    "use strict";
    var ArgHandler = require_ArgHandler();
    var addressConverter = require_addressConverter();
    var Range = class {
      // /**
      //  * Creates a new instance of Range.
      //  * @param {Cell} startCell - The start cell.
      //  * @param {Cell} endCell - The end cell.
      //  */
      constructor(startCell, endCell) {
        this._startCell = startCell;
        this._endCell = endCell;
        this._findRangeExtent(startCell, endCell);
      }
      /**
       * Get the address of the range.
       * @param {{}} [opts] - Options
       * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.
       * @param {boolean} [opts.startRowAnchored] - Anchor the start row.
       * @param {boolean} [opts.startColumnAnchored] - Anchor the start column.
       * @param {boolean} [opts.endRowAnchored] - Anchor the end row.
       * @param {boolean} [opts.endColumnAnchored] - Anchor the end column.
       * @param {boolean} [opts.anchored] - Anchor all row and columns.
       * @returns {string} The address.
       */
      address(opts) {
        return addressConverter.toAddress({
          type: "range",
          startRowNumber: this.startCell().rowNumber(),
          startRowAnchored: opts && (opts.startRowAnchored || opts.anchored),
          startColumnName: this.startCell().columnName(),
          startColumnAnchored: opts && (opts.startColumnAnchored || opts.anchored),
          endRowNumber: this.endCell().rowNumber(),
          endRowAnchored: opts && (opts.endRowAnchored || opts.anchored),
          endColumnName: this.endCell().columnName(),
          endColumnAnchored: opts && (opts.endColumnAnchored || opts.anchored),
          sheetName: opts && opts.includeSheetName && this.sheet().name()
        });
      }
      /**
       * Gets a cell within the range.
       * @param {number} ri - Row index relative to the top-left corner of the range (0-based).
       * @param {number} ci - Column index relative to the top-left corner of the range (0-based).
       * @returns {Cell} The cell.
       */
      cell(ri, ci) {
        return this.sheet().cell(this._minRowNumber + ri, this._minColumnNumber + ci);
      }
      /**
       * Sets sheet autoFilter to this range.
       * @returns {Range} This range.
       */
      autoFilter() {
        this.sheet().autoFilter(this);
        return this;
      }
      /**
       * Get the cells in the range as a 2D array.
       * @returns {Array.<Array.<Cell>>} The cells.
       */
      cells() {
        return this.map((cell) => cell);
      }
      /**
       * Clear the contents of all the cells in the range.
       * @returns {Range} The range.
       */
      clear() {
        return this.value(void 0);
      }
      /**
       * Get the end cell of the range.
       * @returns {Cell} The end cell.
       */
      endCell() {
        return this._endCell;
      }
      /**
       * Callback used by forEach.
       * @callback Range~forEachCallback
       * @param {Cell} cell - The cell.
       * @param {number} ri - The relative row index.
       * @param {number} ci - The relative column index.
       * @param {Range} range - The range.
       * @returns {undefined}
       */
      /**
       * Call a function for each cell in the range. Goes by row then column.
       * @param {Range~forEachCallback} callback - Function called for each cell in the range.
       * @returns {Range} The range.
       */
      forEach(callback) {
        for (let ri = 0; ri < this._numRows; ri++) {
          for (let ci = 0; ci < this._numColumns; ci++) {
            callback(this.cell(ri, ci), ri, ci, this);
          }
        }
        return this;
      }
      /**
       * Gets the shared formula in the start cell (assuming it's the source of the shared formula).
       * @returns {string|undefined} The shared formula.
       */
      /**
      * Sets the shared formula in the range. The formula will be translated for each cell.
      * @param {string} formula - The formula to set.
      * @returns {Range} The range.
      */
      formula() {
        return new ArgHandler("Range.formula").case(() => {
          return this.startCell().getSharedRefFormula();
        }).case("string", (formula) => {
          const sharedFormulaId = this.sheet().incrementMaxSharedFormulaId();
          this.forEach((cell, ri, ci) => {
            if (ri === 0 && ci === 0) {
              cell.setSharedFormula(sharedFormulaId, formula, this.address());
            } else {
              cell.setSharedFormula(sharedFormulaId);
            }
          });
          return this;
        }).handle(arguments);
      }
      /**
       * Callback used by map.
       * @callback Range~mapCallback
       * @param {Cell} cell - The cell.
       * @param {number} ri - The relative row index.
       * @param {number} ci - The relative column index.
       * @param {Range} range - The range.
       * @returns {*} The value to map to.
       */
      /**
       * Creates a 2D array of values by running each cell through a callback.
       * @param {Range~mapCallback} callback - Function called for each cell in the range.
       * @returns {Array.<Array.<*>>} The 2D array of return values.
       */
      map(callback) {
        const result = [];
        this.forEach((cell, ri, ci) => {
          if (!result[ri])
            result[ri] = [];
          result[ri][ci] = callback(cell, ri, ci, this);
        });
        return result;
      }
      /**
       * Gets a value indicating whether the cells in the range are merged.
       * @returns {boolean} The value.
       */
      /**
      * Sets a value indicating whether the cells in the range should be merged.
      * @param {boolean} merged - True to merge, false to unmerge.
      * @returns {Range} The range.
      */
      merged(merged) {
        return new ArgHandler("Range.merged").case(() => {
          return this.sheet().merged(this.address());
        }).case("*", (merged2) => {
          this.sheet().merged(this.address(), merged2);
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the data validation object attached to the Range.
       * @returns {object|undefined} The data validation object or undefined if not set.
       */
      /**
      * Set or clear the data validation object of the entire range.
      * @param {object|undefined} dataValidation - Object or null to clear.
      * @returns {Range} The range.
      */
      dataValidation() {
        return new ArgHandler("Range.dataValidation").case(() => {
          return this.sheet().dataValidation(this.address());
        }).case("boolean", (obj) => {
          return this.sheet().dataValidation(this.address(), obj);
        }).case("*", (obj) => {
          this.sheet().dataValidation(this.address(), obj);
          return this;
        }).handle(arguments);
      }
      /**
       * Callback used by reduce.
       * @callback Range~reduceCallback
       * @param {*} accumulator - The accumulated value.
       * @param {Cell} cell - The cell.
       * @param {number} ri - The relative row index.
       * @param {number} ci - The relative column index.
       * @param {Range} range - The range.
       * @returns {*} The value to map to.
       */
      /**
       * Reduces the range to a single value accumulated from the result of a function called for each cell.
       * @param {Range~reduceCallback} callback - Function called for each cell in the range.
       * @param {*} [initialValue] - The initial value.
       * @returns {*} The accumulated value.
       */
      reduce(callback, initialValue) {
        let accumulator = initialValue;
        this.forEach((cell, ri, ci) => {
          accumulator = callback(accumulator, cell, ri, ci, this);
        });
        return accumulator;
      }
      /**
       * Gets the parent sheet of the range.
       * @returns {Sheet} The parent sheet.
       */
      sheet() {
        return this.startCell().sheet();
      }
      /**
       * Gets the start cell of the range.
       * @returns {Cell} The start cell.
       */
      startCell() {
        return this._startCell;
      }
      /**
       * Gets a single style for each cell.
       * @param {string} name - The name of the style.
       * @returns {Array.<Array.<*>>} 2D array of style values.
       */
      /**
      * Gets multiple styles for each cell.
      * @param {Array.<string>} names - The names of the styles.
      * @returns {Object.<string, Array.<Array.<*>>>} Object whose keys are style names and values are 2D arrays of style values.
      */
      /**
      * Set the style in each cell to the result of a function called for each.
      * @param {string} name - The name of the style.
      * @param {Range~mapCallback} callback - The callback to provide value for the cell.
      * @returns {Range} The range.
      */
      /**
      * Sets the style in each cell to the corresponding value in the given 2D array of values.
      * @param {string} name - The name of the style.
      * @param {Array.<Array.<*>>} values - The style values to set.
      * @returns {Range} The range.
      */
      /**
      * Set the style of all cells in the range to a single style value.
      * @param {string} name - The name of the style.
      * @param {*} value - The value to set.
      * @returns {Range} The range.
      */
      /**
      * Set multiple styles for the cells in the range.
      * @param {object.<string,Range~mapCallback|Array.<Array.<*>>|*>} styles - Object whose keys are style names and values are either function callbacks, 2D arrays of style values, or a single value for all the cells.
      * @returns {Range} The range.
      */
      /**
      * Sets to a specific style
      * @param {Style} style - Style object given from stylesheet.createStyle
      * @returns {Range} The range.
      */
      style() {
        return new ArgHandler("Range.style").case("string", (name) => {
          return this.map((cell) => cell.style(name));
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this.style(name);
          });
          return values;
        }).case(["string", "function"], (name, callback) => {
          return this.forEach((cell, ri, ci) => {
            cell.style(name, callback(cell, ri, ci, this));
          });
        }).case(["string", "array"], (name, values) => {
          return this.forEach((cell, ri, ci) => {
            if (values[ri] && values[ri][ci] !== void 0) {
              cell.style(name, values[ri][ci]);
            }
          });
        }).case(["string", "*"], (name, value) => {
          return this.forEach((cell) => cell.style(name, value));
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this.style(name, value);
          }
          return this;
        }).case("Style", (style) => {
          this._style = style;
          return this.forEach((cell) => cell.style(style));
        }).handle(arguments);
      }
      /**
       * Callback used by tap.
       * @callback Range~tapCallback
       * @param {Range} range - The range.
       * @returns {undefined}
       */
      /**
       * Invoke a callback on the range and return the range. Useful for method chaining.
       * @param {Range~tapCallback} callback - The callback function.
       * @returns {Range} The range.
       */
      tap(callback) {
        callback(this);
        return this;
      }
      /**
       * Callback used by thru.
       * @callback Range~thruCallback
       * @param {Range} range - The range.
       * @returns {*} The value to return from thru.
       */
      /**
       * Invoke a callback on the range and return the value provided by the callback. Useful for method chaining.
       * @param {Range~thruCallback} callback - The callback function.
       * @returns {*} The return value of the callback.
       */
      thru(callback) {
        return callback(this);
      }
      /**
       * Get the values of each cell in the range as a 2D array.
       * @returns {Array.<Array.<*>>} The values.
       */
      /**
      * Set the values in each cell to the result of a function called for each.
      * @param {Range~mapCallback} callback - The callback to provide value for the cell.
      * @returns {Range} The range.
      */
      /**
      * Sets the value in each cell to the corresponding value in the given 2D array of values.
      * @param {Array.<Array.<*>>} values - The values to set.
      * @returns {Range} The range.
      */
      /**
      * Set the value of all cells in the range to a single value.
      * @param {*} value - The value to set.
      * @returns {Range} The range.
      */
      value() {
        return new ArgHandler("Range.value").case(() => {
          return this.map((cell) => cell.value());
        }).case("function", (callback) => {
          return this.forEach((cell, ri, ci) => {
            cell.value(callback(cell, ri, ci, this));
          });
        }).case("array", (values) => {
          return this.forEach((cell, ri, ci) => {
            if (values[ri] && values[ri][ci] !== void 0) {
              cell.value(values[ri][ci]);
            }
          });
        }).case("*", (value) => {
          return this.forEach((cell) => cell.value(value));
        }).handle(arguments);
      }
      /**
       * Gets the parent workbook.
       * @returns {Workbook} The parent workbook.
       */
      workbook() {
        return this.sheet().workbook();
      }
      /**
       * Find the extent of the range.
       * @returns {undefined}
       * @private
       */
      _findRangeExtent() {
        this._minRowNumber = Math.min(this._startCell.rowNumber(), this._endCell.rowNumber());
        this._maxRowNumber = Math.max(this._startCell.rowNumber(), this._endCell.rowNumber());
        this._minColumnNumber = Math.min(this._startCell.columnNumber(), this._endCell.columnNumber());
        this._maxColumnNumber = Math.max(this._startCell.columnNumber(), this._endCell.columnNumber());
        this._numRows = this._maxRowNumber - this._minRowNumber + 1;
        this._numColumns = this._maxColumnNumber - this._minColumnNumber + 1;
      }
    };
    module.exports = Range;
  }
});

// node_modules/xlsx-populate/lib/Relationships.js
var require_Relationships = __commonJS({
  "node_modules/xlsx-populate/lib/Relationships.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var RELATIONSHIP_SCHEMA_PREFIX = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/";
    var Relationships = class {
      /**
       * Creates a new instance of _Relationships.
       * @param {{}} node - The node.
       */
      constructor(node) {
        this._init(node);
        this._getStartingId();
      }
      /**
       * Add a new relationship.
       * @param {string} type - The type of relationship.
       * @param {string} target - The target of the relationship.
       * @param {string} [targetMode] - The target mode of the relationship.
       * @returns {{}} The new relationship.
       */
      add(type, target, targetMode) {
        const node = {
          name: "Relationship",
          attributes: {
            Id: `rId${this._nextId++}`,
            Type: `${RELATIONSHIP_SCHEMA_PREFIX}${type}`,
            Target: target
          }
        };
        if (targetMode) {
          node.attributes.TargetMode = targetMode;
        }
        this._node.children.push(node);
        return node;
      }
      /**
       * Find a relationship by ID.
       * @param {string} id - The relationship ID.
       * @returns {{}|undefined} The matching relationship or undefined if not found.
       */
      findById(id) {
        return _.find(this._node.children, (node) => node.attributes.Id === id);
      }
      /**
       * Find a relationship by type.
       * @param {string} type - The type to search for.
       * @returns {{}|undefined} The matching relationship or undefined if not found.
       */
      findByType(type) {
        return _.find(this._node.children, (node) => node.attributes.Type === `${RELATIONSHIP_SCHEMA_PREFIX}${type}`);
      }
      /**
       * Convert the collection to an XML object.
       * @returns {{}|undefined} The XML or undefined if empty.
       */
      toXml() {
        if (!this._node.children.length)
          return;
        return this._node;
      }
      /**
       * Get the starting relationship ID to use for new relationships.
       * @private
       * @returns {undefined}
       */
      _getStartingId() {
        this._nextId = 1;
        this._node.children.forEach((node) => {
          const id = parseInt(node.attributes.Id.substr(3));
          if (id >= this._nextId)
            this._nextId = id + 1;
        });
      }
      /**
       * Initialize the node.
       * @param {{}} [node] - The relationships node.
       * @private
       * @returns {undefined}
       */
      _init(node) {
        if (!node)
          node = {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            children: []
          };
        this._node = node;
      }
    };
    module.exports = Relationships;
  }
});

// node_modules/xlsx-populate/lib/PageBreaks.js
var require_PageBreaks = __commonJS({
  "node_modules/xlsx-populate/lib/PageBreaks.js"(exports, module) {
    "use strict";
    var PageBreaks = class {
      constructor(node) {
        this._node = node;
      }
      /**
       * add page-breaks by row/column id
       * @param {number} id - row/column id (rowNumber/colNumber)
       * @return {PageBreaks} the page-breaks
       */
      add(id) {
        this._node.children.push({
          name: "brk",
          children: [],
          attributes: {
            id,
            max: 16383,
            man: 1
          }
        });
        this._node.attributes.count++;
        this._node.attributes.manualBreakCount++;
        return this;
      }
      /**
       * remove page-breaks by index
       * @param {number} index - index of list
       * @return {PageBreaks} the page-breaks
       */
      remove(index) {
        const brk = this._node.children[index];
        if (brk) {
          this._node.children.splice(index, 1);
          this._node.attributes.count--;
          if (brk.man) {
            this._node.attributes.manualBreakCount--;
          }
        }
        return this;
      }
      /**
       * get count of the page-breaks
       * @return {number} the page-breaks' count
       */
      get count() {
        return this._node.attributes.count;
      }
      /**
       * get list of page-breaks
       * @return {Array} list of the page-breaks
       */
      get list() {
        return this._node.children.map((brk) => ({
          id: brk.id,
          isManual: !!brk.man
        }));
      }
    };
    module.exports = PageBreaks;
  }
});

// node_modules/xlsx-populate/lib/Sheet.js
var require_Sheet = __commonJS({
  "node_modules/xlsx-populate/lib/Sheet.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var Cell = require_Cell();
    var Row = require_Row();
    var Column = require_Column();
    var Range = require_Range();
    var Relationships = require_Relationships();
    var xmlq = require_xmlq();
    var regexify = require_regexify();
    var addressConverter = require_addressConverter();
    var ArgHandler = require_ArgHandler();
    var colorIndexes = require_colorIndexes();
    var PageBreaks = require_PageBreaks();
    var nodeOrder = [
      "sheetPr",
      "dimension",
      "sheetViews",
      "sheetFormatPr",
      "cols",
      "sheetData",
      "sheetCalcPr",
      "sheetProtection",
      "autoFilter",
      "protectedRanges",
      "scenarios",
      "autoFilter",
      "sortState",
      "dataConsolidate",
      "customSheetViews",
      "mergeCells",
      "phoneticPr",
      "conditionalFormatting",
      "dataValidations",
      "hyperlinks",
      "printOptions",
      "pageMargins",
      "pageSetup",
      "headerFooter",
      "rowBreaks",
      "colBreaks",
      "customProperties",
      "cellWatches",
      "ignoredErrors",
      "smartTags",
      "drawing",
      "drawingHF",
      "legacyDrawing",
      "legacyDrawingHF",
      "picture",
      "oleObjects",
      "controls",
      "webPublishItems",
      "tableParts",
      "extLst"
    ];
    var Sheet = class {
      // /**
      //  * Creates a new instance of Sheet.
      //  * @param {Workbook} workbook - The parent workbook.
      //  * @param {{}} idNode - The sheet ID node (from the parent workbook).
      //  * @param {{}} node - The sheet node.
      //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.
      //  */
      constructor(workbook, idNode, node, relationshipsNode) {
        this._init(workbook, idNode, node, relationshipsNode);
      }
      /* PUBLIC */
      /**
       * Gets a value indicating whether the sheet is the active sheet in the workbook.
       * @returns {boolean} True if active, false otherwise.
       */
      /**
      * Make the sheet the active sheet in the workkbok.
      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.
      * @returns {Sheet} The sheet.
      */
      active() {
        return new ArgHandler("Sheet.active").case(() => {
          return this.workbook().activeSheet() === this;
        }).case("boolean", (active) => {
          if (!active)
            throw new Error("Deactivating sheet directly not supported. Activate a different sheet instead.");
          this.workbook().activeSheet(this);
          return this;
        }).handle(arguments);
      }
      /**
       * Get the active cell in the sheet.
       * @returns {Cell} The active cell.
       */
      /**
      * Set the active cell in the workbook.
      * @param {string|Cell} cell - The cell or address of cell to activate.
      * @returns {Sheet} The sheet.
      */
      /**
      * Set the active cell in the workbook by row and column.
      * @param {number} rowNumber - The row number of the cell.
      * @param {string|number} columnNameOrNumber - The column name or number of the cell.
      * @returns {Sheet} The sheet.
      */
      activeCell() {
        const sheetViewNode = this._getOrCreateSheetViewNode();
        let selectionNode = xmlq.findChild(sheetViewNode, "selection");
        return new ArgHandler("Sheet.activeCell").case(() => {
          const cellAddress = selectionNode ? selectionNode.attributes.activeCell : "A1";
          return this.cell(cellAddress);
        }).case(["number", "*"], (rowNumber, columnNameOrNumber) => {
          const cell = this.cell(rowNumber, columnNameOrNumber);
          return this.activeCell(cell);
        }).case("*", (cell) => {
          if (!selectionNode) {
            selectionNode = {
              name: "selection",
              attributes: {},
              children: []
            };
            xmlq.appendChild(sheetViewNode, selectionNode);
          }
          if (!(cell instanceof Cell))
            cell = this.cell(cell);
          selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();
          return this;
        }).handle(arguments);
      }
      /**
       * Gets the cell with the given address.
       * @param {string} address - The address of the cell.
       * @returns {Cell} The cell.
       */
      /**
      * Gets the cell with the given row and column numbers.
      * @param {number} rowNumber - The row number of the cell.
      * @param {string|number} columnNameOrNumber - The column name or number of the cell.
      * @returns {Cell} The cell.
      */
      cell() {
        return new ArgHandler("Sheet.cell").case("string", (address) => {
          const ref = addressConverter.fromAddress(address);
          if (ref.type !== "cell")
            throw new Error("Sheet.cell: Invalid address.");
          return this.row(ref.rowNumber).cell(ref.columnNumber);
        }).case(["number", "*"], (rowNumber, columnNameOrNumber) => {
          return this.row(rowNumber).cell(columnNameOrNumber);
        }).handle(arguments);
      }
      /**
       * Gets a column in the sheet.
       * @param {string|number} columnNameOrNumber - The name or number of the column.
       * @returns {Column} The column.
       */
      column(columnNameOrNumber) {
        const columnNumber = typeof columnNameOrNumber === "string" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;
        if (this._columns[columnNumber])
          return this._columns[columnNumber];
        const existingColNode = this._colNodes[columnNumber];
        let colNode;
        if (existingColNode) {
          if (existingColNode.attributes.min < columnNumber) {
            const beforeColNode = _.cloneDeep(existingColNode);
            beforeColNode.attributes.max = columnNumber - 1;
            for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {
              this._colNodes[i] = beforeColNode;
            }
          }
          colNode = _.cloneDeep(existingColNode);
          colNode.attributes.min = columnNumber;
          colNode.attributes.max = columnNumber;
          this._colNodes[columnNumber] = colNode;
          if (existingColNode.attributes.max > columnNumber) {
            const afterColNode = _.cloneDeep(existingColNode);
            afterColNode.attributes.min = columnNumber + 1;
            for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {
              this._colNodes[i] = afterColNode;
            }
          }
        } else {
          colNode = {
            name: "col",
            attributes: {
              min: columnNumber,
              max: columnNumber
            },
            children: []
          };
          this._colNodes[columnNumber] = colNode;
        }
        const column = new Column(this, colNode);
        this._columns[columnNumber] = column;
        return column;
      }
      /**
       * Gets a defined name scoped to the sheet.
       * @param {string} name - The defined name.
       * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.
       */
      /**
      * Set a defined name scoped to the sheet.
      * @param {string} name - The defined name.
      * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.
      * @returns {Workbook} The workbook.
      */
      definedName() {
        return new ArgHandler("Workbook.definedName").case("string", (name) => {
          return this.workbook().scopedDefinedName(this, name);
        }).case(["string", "*"], (name, refersTo) => {
          this.workbook().scopedDefinedName(this, name, refersTo);
          return this;
        }).handle(arguments);
      }
      /**
       * Deletes the sheet and returns the parent workbook.
       * @returns {Workbook} The workbook.
       */
      delete() {
        this.workbook().deleteSheet(this);
        return this.workbook();
      }
      /**
       * Find the given pattern in the sheet and optionally replace it.
       * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.
       * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.
       * @returns {Array.<Cell>} The matching cells.
       */
      find(pattern, replacement) {
        pattern = regexify(pattern);
        let matches = [];
        this._rows.forEach((row) => {
          if (!row)
            return;
          matches = matches.concat(row.find(pattern, replacement));
        });
        return matches;
      }
      /**
       * Gets a value indicating whether this sheet's grid lines are visible.
       * @returns {boolean} True if selected, false if not.
       */
      /**
      * Sets whether this sheet's grid lines are visible.
      * @param {boolean} selected - True to make visible, false to hide.
      * @returns {Sheet} The sheet.
      */
      gridLinesVisible() {
        const sheetViewNode = this._getOrCreateSheetViewNode();
        return new ArgHandler("Sheet.gridLinesVisible").case(() => {
          return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === void 0;
        }).case("boolean", (visible) => {
          sheetViewNode.attributes.showGridLines = visible ? 1 : 0;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a value indicating if the sheet is hidden or not.
       * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.
       */
      /**
      * Set whether the sheet is hidden or not.
      * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.
      * @returns {Sheet} The sheet.
      */
      hidden() {
        return new ArgHandler("Sheet.hidden").case(() => {
          if (this._idNode.attributes.state === "hidden")
            return true;
          if (this._idNode.attributes.state === "veryHidden")
            return "very";
          return false;
        }).case("*", (hidden) => {
          if (hidden) {
            const visibleSheets = _.filter(this.workbook().sheets(), (sheet) => !sheet.hidden());
            if (visibleSheets.length === 1 && visibleSheets[0] === this) {
              throw new Error("This sheet may not be hidden as a workbook must contain at least one visible sheet.");
            }
            if (this.active()) {
              const activeIndex = visibleSheets[0] === this ? 1 : 0;
              visibleSheets[activeIndex].active(true);
            }
          }
          if (hidden === "very")
            this._idNode.attributes.state = "veryHidden";
          else if (hidden)
            this._idNode.attributes.state = "hidden";
          else
            delete this._idNode.attributes.state;
          return this;
        }).handle(arguments);
      }
      /**
       * Move the sheet.
       * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
       * @returns {Sheet} The sheet.
       */
      move(indexOrBeforeSheet) {
        this.workbook().moveSheet(this, indexOrBeforeSheet);
        return this;
      }
      /**
       * Get the name of the sheet.
       * @returns {string} The sheet name.
       */
      /**
      * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*
      * @param {string} name - The name to set to the sheet.
      * @returns {Sheet} The sheet.
      */
      name() {
        return new ArgHandler("Sheet.name").case(() => {
          return `${this._idNode.attributes.name}`;
        }).case("string", (name) => {
          this._idNode.attributes.name = name;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a range from the given range address.
       * @param {string} address - The range address (e.g. 'A1:B3').
       * @returns {Range} The range.
       */
      /**
      * Gets a range from the given cells or cell addresses.
      * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').
      * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').
      * @returns {Range} The range.
      */
      /**
      * Gets a range from the given row numbers and column names or numbers.
      * @param {number} startRowNumber - The starting cell row number.
      * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.
      * @param {number} endRowNumber - The ending cell row number.
      * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.
      * @returns {Range} The range.
      */
      range() {
        return new ArgHandler("Sheet.range").case("string", (address) => {
          const ref = addressConverter.fromAddress(address);
          if (ref.type !== "range")
            throw new Error("Sheet.range: Invalid address");
          return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);
        }).case(["*", "*"], (startCell, endCell) => {
          if (typeof startCell === "string")
            startCell = this.cell(startCell);
          if (typeof endCell === "string")
            endCell = this.cell(endCell);
          return new Range(startCell, endCell);
        }).case(["number", "*", "number", "*"], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {
          return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));
        }).handle(arguments);
      }
      /**
       * Unsets sheet autoFilter.
       * @returns {Sheet} This sheet.
       */
      /**
      * Sets sheet autoFilter to a Range.
      * @param {Range} range - The autoFilter range.
      * @returns {Sheet} This sheet.
      */
      autoFilter(range) {
        this._autoFilter = range;
        return this;
      }
      /**
       * Gets the row with the given number.
       * @param {number} rowNumber - The row number.
       * @returns {Row} The row with the given number.
       */
      row(rowNumber) {
        if (rowNumber < 1)
          throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);
        if (this._rows[rowNumber])
          return this._rows[rowNumber];
        const rowNode = {
          name: "row",
          attributes: {
            r: rowNumber
          },
          children: []
        };
        const row = new Row(this, rowNode);
        this._rows[rowNumber] = row;
        return row;
      }
      /**
       * Get the tab color. (See style [Color](#color).)
       * @returns {undefined|Color} The color or undefined if not set.
       */
      /**
      * Sets the tab color. (See style [Color](#color).)
      * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.
      */
      tabColor() {
        return new ArgHandler("Sheet.tabColor").case(() => {
          const tabColorNode = xmlq.findChild(this._sheetPrNode, "tabColor");
          if (!tabColorNode)
            return;
          const color = {};
          if (tabColorNode.attributes.hasOwnProperty("rgb"))
            color.rgb = tabColorNode.attributes.rgb;
          else if (tabColorNode.attributes.hasOwnProperty("theme"))
            color.theme = tabColorNode.attributes.theme;
          else if (tabColorNode.attributes.hasOwnProperty("indexed"))
            color.rgb = colorIndexes[tabColorNode.attributes.indexed];
          if (tabColorNode.attributes.hasOwnProperty("tint"))
            color.tint = tabColorNode.attributes.tint;
          return color;
        }).case("string", (rgb) => this.tabColor({ rgb })).case("integer", (theme) => this.tabColor({ theme })).case("nil", () => {
          xmlq.removeChild(this._sheetPrNode, "tabColor");
          return this;
        }).case("object", (color) => {
          const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, "tabColor");
          xmlq.setAttributes(tabColorNode, {
            rgb: color.rgb && color.rgb.toUpperCase(),
            indexed: null,
            theme: color.theme,
            tint: color.tint
          });
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a value indicating whether this sheet is selected.
       * @returns {boolean} True if selected, false if not.
       */
      /**
      * Sets whether this sheet is selected.
      * @param {boolean} selected - True to select, false to deselected.
      * @returns {Sheet} The sheet.
      */
      tabSelected() {
        const sheetViewNode = this._getOrCreateSheetViewNode();
        return new ArgHandler("Sheet.tabSelected").case(() => {
          return sheetViewNode.attributes.tabSelected === 1;
        }).case("boolean", (selected) => {
          if (selected)
            sheetViewNode.attributes.tabSelected = 1;
          else
            delete sheetViewNode.attributes.tabSelected;
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a value indicating whether this sheet is rtl (Right To Left).
       * @returns {boolean} True if rtl, false if ltr.
       */
      /**
      * Sets whether this sheet is rtl.
      * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).
      * @returns {Sheet} The sheet.
      */
      rightToLeft() {
        const sheetViewNode = this._getOrCreateSheetViewNode();
        return new ArgHandler("Sheet.rightToLeft").case(() => {
          return sheetViewNode.attributes.rightToLeft;
        }).case("boolean", (rtl) => {
          if (rtl)
            sheetViewNode.attributes.rightToLeft = true;
          else
            delete sheetViewNode.attributes.rightToLeft;
          return this;
        }).handle(arguments);
      }
      /**
       * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.
       * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.
       */
      usedRange() {
        const minRowNumber = _.findIndex(this._rows);
        const maxRowNumber = this._rows.length - 1;
        let minColumnNumber = 0;
        let maxColumnNumber = 0;
        for (let i = 0; i < this._rows.length; i++) {
          const row = this._rows[i];
          if (!row)
            continue;
          const minUsedColumnNumber = row.minUsedColumnNumber();
          const maxUsedColumnNumber = row.maxUsedColumnNumber();
          if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber))
            minColumnNumber = minUsedColumnNumber;
          if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber))
            maxColumnNumber = maxUsedColumnNumber;
        }
        if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0)
          return;
        return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);
      }
      /**
       * Gets the parent workbook.
       * @returns {Workbook} The parent workbook.
       */
      workbook() {
        return this._workbook;
      }
      /**
       * Gets all page breaks.
       * @returns {{}} the object holds both vertical and horizontal PageBreaks.
       */
      pageBreaks() {
        return this._pageBreaks;
      }
      /**
       * Gets the vertical page breaks.
       * @returns {PageBreaks} vertical PageBreaks.
       */
      verticalPageBreaks() {
        return this._pageBreaks.colBreaks;
      }
      /**
       * Gets the horizontal page breaks.
       * @returns {PageBreaks} horizontal PageBreaks.
       */
      horizontalPageBreaks() {
        return this._pageBreaks.rowBreaks;
      }
      /* INTERNAL */
      /**
       * Clear cells that are using a given shared formula ID.
       * @param {number} sharedFormulaId - The shared formula ID.
       * @returns {undefined}
       * @ignore
       */
      clearCellsUsingSharedFormula(sharedFormulaId) {
        this._rows.forEach((row) => {
          if (!row)
            return;
          row.clearCellsUsingSharedFormula(sharedFormulaId);
        });
      }
      /**
       * Get an existing column style ID.
       * @param {number} columnNumber - The column number.
       * @returns {undefined|number} The style ID.
       * @ignore
       */
      existingColumnStyleId(columnNumber) {
        const colNode = this._colNodes[columnNumber];
        return colNode && colNode.attributes.style;
      }
      /**
       * Call a callback for each column number that has a node defined for it.
       * @param {Function} callback - The callback.
       * @returns {undefined}
       * @ignore
       */
      forEachExistingColumnNumber(callback) {
        _.forEach(this._colNodes, (node, columnNumber) => {
          if (!node)
            return;
          callback(columnNumber);
        });
      }
      /**
       * Call a callback for each existing row.
       * @param {Function} callback - The callback.
       * @returns {undefined}
       * @ignore
       */
      forEachExistingRow(callback) {
        _.forEach(this._rows, (row, rowNumber) => {
          if (row)
            callback(row, rowNumber);
        });
        return this;
      }
      /**
       * Get the hyperlink attached to the cell with the given address.
       * @param {string} address - The address of the hyperlinked cell.
       * @returns {string|undefined} The hyperlink or undefined if not set.
       */
      /**
      * Set the hyperlink on the cell with the given address.
      * @param {string} address - The address of the hyperlinked cell.
      * @param {string} hyperlink - The hyperlink to set or undefined to clear.
      * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.
      * @returns {Sheet} The sheet.
      */
      /**
      * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.
      * @param {string} address - The address of the hyperlinked cell.
      * @param {object|Cell} opts - Options.
      * @returns {Sheet} The sheet.
      * @ignore
      */
      /**
      * Set the hyperlink on the cell with the given address and options.
      * @param {string} address - The address of the hyperlinked cell.
      * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.
      * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.
      * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.
      * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.
      * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.
      * @returns {Sheet} The sheet.
      */
      hyperlink() {
        return new ArgHandler("Sheet.hyperlink").case("string", (address) => {
          const hyperlinkNode = this._hyperlinks[address];
          if (!hyperlinkNode)
            return;
          const relationship = this._relationships.findById(hyperlinkNode.attributes["r:id"]);
          return relationship && relationship.attributes.Target;
        }).case(["string", "nil"], (address) => {
          delete this._hyperlinks[address];
          return this;
        }).case(["string", "string"], (address, hyperlink) => {
          return this.hyperlink(address, hyperlink, false);
        }).case(["string", "string", "boolean"], (address, hyperlink, internal) => {
          const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);
          let nodeAttributes;
          if (isHyperlinkInternalAddress) {
            nodeAttributes = {
              ref: address,
              location: hyperlink,
              display: hyperlink
            };
          } else {
            const relationship = this._relationships.add("hyperlink", hyperlink, "External");
            nodeAttributes = {
              ref: address,
              "r:id": relationship.attributes.Id
            };
          }
          this._hyperlinks[address] = {
            name: "hyperlink",
            attributes: nodeAttributes,
            children: []
          };
          return this;
        }).case(["string", "object"], (address, opts) => {
          if (opts instanceof Cell) {
            const cell = opts;
            const hyperlink = cell.address({ includeSheetName: true });
            this.hyperlink(address, hyperlink, true);
          } else if (opts.hyperlink) {
            this.hyperlink(address, opts.hyperlink);
          } else if (opts.email) {
            const email = opts.email;
            const subject = opts.emailSubject || "";
            this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));
          }
          const hyperlinkNode = this._hyperlinks[address];
          if (hyperlinkNode) {
            if (opts.tooltip) {
              hyperlinkNode.attributes.tooltip = opts.tooltip;
            }
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Increment and return the max shared formula ID.
       * @returns {number} The new max shared formula ID.
       * @ignore
       */
      incrementMaxSharedFormulaId() {
        return ++this._maxSharedFormulaId;
      }
      /**
       * Get a value indicating whether the cells in the given address are merged.
       * @param {string} address - The address to check.
       * @returns {boolean} True if merged, false if not merged.
       * @ignore
       */
      /**
      * Merge/unmerge cells by adding/removing a mergeCell entry.
      * @param {string} address - The address to merge.
      * @param {boolean} merged - True to merge, false to unmerge.
      * @returns {Sheet} The sheet.
      * @ignore
      */
      merged() {
        return new ArgHandler("Sheet.merge").case("string", (address) => {
          return this._mergeCells.hasOwnProperty(address);
        }).case(["string", "*"], (address, merge) => {
          if (merge) {
            this._mergeCells[address] = {
              name: "mergeCell",
              attributes: { ref: address },
              children: []
            };
          } else {
            delete this._mergeCells[address];
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Gets a Object or undefined of the cells in the given address.
       * @param {string} address - The address to check.
       * @returns {object|boolean} Object or false if not set
       * @ignore
       */
      /**
      * Removes dataValidation at the given address
      * @param {string} address - The address to remove.
      * @param {boolean} obj - false to delete.
      * @returns {boolean} true if removed.
      * @ignore
      */
      /**
      * Add dataValidation to cells at the given address if object or string
      * @param {string} address - The address to set.
      * @param {object|string} obj - Object or String to set
      * @returns {Sheet} The sheet.
      * @ignore
      */
      dataValidation() {
        return new ArgHandler("Sheet.dataValidation").case("string", (address) => {
          if (this._dataValidations[address]) {
            return {
              type: this._dataValidations[address].attributes.type,
              allowBlank: this._dataValidations[address].attributes.allowBlank,
              showInputMessage: this._dataValidations[address].attributes.showInputMessage,
              prompt: this._dataValidations[address].attributes.prompt,
              promptTitle: this._dataValidations[address].attributes.promptTitle,
              showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,
              error: this._dataValidations[address].attributes.error,
              errorTitle: this._dataValidations[address].attributes.errorTitle,
              operator: this._dataValidations[address].attributes.operator,
              formula1: this._dataValidations[address].children[0].children[0],
              formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : void 0
            };
          } else {
            return false;
          }
        }).case(["string", "boolean"], (address, obj) => {
          if (this._dataValidations[address]) {
            if (obj === false)
              return delete this._dataValidations[address];
          } else {
            return false;
          }
        }).case(["string", "*"], (address, obj) => {
          if (typeof obj === "string") {
            this._dataValidations[address] = {
              name: "dataValidation",
              attributes: {
                type: "list",
                allowBlank: false,
                showInputMessage: false,
                prompt: "",
                promptTitle: "",
                showErrorMessage: false,
                error: "",
                errorTitle: "",
                operator: "",
                sqref: address
              },
              children: [
                {
                  name: "formula1",
                  atrributes: {},
                  children: [obj]
                },
                {
                  name: "formula2",
                  atrributes: {},
                  children: [""]
                }
              ]
            };
          } else if (typeof obj === "object") {
            this._dataValidations[address] = {
              name: "dataValidation",
              attributes: {
                type: obj.type ? obj.type : "list",
                allowBlank: obj.allowBlank,
                showInputMessage: obj.showInputMessage,
                prompt: obj.prompt,
                promptTitle: obj.promptTitle,
                showErrorMessage: obj.showErrorMessage,
                error: obj.error,
                errorTitle: obj.errorTitle,
                operator: obj.operator,
                sqref: address
              },
              children: [
                {
                  name: "formula1",
                  atrributes: {},
                  children: [
                    obj.formula1
                  ]
                },
                {
                  name: "formula2",
                  atrributes: {},
                  children: [
                    obj.formula2
                  ]
                }
              ]
            };
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Convert the sheet to a collection of XML objects.
       * @returns {{}} The XML forms.
       * @ignore
       */
      toXmls() {
        const node = _.clone(this._node);
        node.children = node.children.slice();
        this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {
          return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;
        });
        if (this._colsNode.children.length) {
          xmlq.insertInOrder(node, this._colsNode, nodeOrder);
        }
        this._hyperlinksNode.children = _.values(this._hyperlinks);
        if (this._hyperlinksNode.children.length) {
          xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);
        }
        if (this._printOptionsNode) {
          if (Object.keys(this._printOptionsNode.attributes).length) {
            xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);
          }
        }
        if (this._pageMarginsNode && this._pageMarginsPresetName) {
          const childNode = _.clone(this._pageMarginsNode);
          if (Object.keys(this._pageMarginsNode.attributes).length) {
            childNode.attributes = _.assign(
              this._pageMarginsPresets[this._pageMarginsPresetName],
              this._pageMarginsNode.attributes
            );
          } else {
            childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];
          }
          xmlq.insertInOrder(node, childNode, nodeOrder);
        }
        this._mergeCellsNode.children = _.values(this._mergeCells);
        if (this._mergeCellsNode.children.length) {
          xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);
        }
        this._dataValidationsNode.children = _.values(this._dataValidations);
        if (this._dataValidationsNode.children.length) {
          xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);
        }
        if (this._autoFilter) {
          xmlq.insertInOrder(node, {
            name: "autoFilter",
            children: [],
            attributes: {
              ref: this._autoFilter.address()
            }
          }, nodeOrder);
        }
        ["colBreaks", "rowBreaks"].forEach((name) => {
          const breaks = this[`_${name}Node`];
          if (breaks.attributes.count) {
            xmlq.insertInOrder(node, breaks, nodeOrder);
          }
        });
        return {
          id: this._idNode,
          sheet: node,
          relationships: this._relationships
        };
      }
      /**
       * Update the max shared formula ID to the given value if greater than current.
       * @param {number} sharedFormulaId - The new shared formula ID.
       * @returns {undefined}
       * @ignore
       */
      updateMaxSharedFormulaId(sharedFormulaId) {
        if (sharedFormulaId > this._maxSharedFormulaId) {
          this._maxSharedFormulaId = sharedFormulaId;
        }
      }
      /**
       * Get the print option given a valid print option attribute.
       * @param {string} attributeName - Attribute name of the printOptions.
       *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).
       *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).
       *   headings - Print row and column headings.
       *   horizontalCentered - Center on page horizontally when printing.
       *   verticalCentered - Center on page vertically when printing.
       * @returns {boolean}
       */
      /**
      * Set the print option given a valid print option attribute and a value.
      * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.
      * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.
      * @returns {Sheet} The sheet.
      */
      printOptions() {
        const supportedAttributeNames = [
          "gridLines",
          "gridLinesSet",
          "headings",
          "horizontalCentered",
          "verticalCentered"
        ];
        const checkAttributeName = this._getCheckAttributeNameHelper("printOptions", supportedAttributeNames);
        return new ArgHandler("Sheet.printOptions").case(["string"], (attributeName) => {
          checkAttributeName(attributeName);
          return this._printOptionsNode.attributes[attributeName] === 1;
        }).case(["string", "nil"], (attributeName) => {
          checkAttributeName(attributeName);
          delete this._printOptionsNode.attributes[attributeName];
          return this;
        }).case(["string", "boolean"], (attributeName, attributeEnabled) => {
          checkAttributeName(attributeName);
          if (attributeEnabled) {
            this._printOptionsNode.attributes[attributeName] = 1;
            return this;
          } else {
            return this.printOptions(attributeName, void 0);
          }
        }).handle(arguments);
      }
      /**
       * Get the print option for the gridLines attribute value.
       * @returns {boolean}
       */
      /**
      * Set the print option for the gridLines attribute value.
      * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.
      * @returns {Sheet} The sheet.
      */
      printGridLines() {
        return new ArgHandler("Sheet.gridLines").case(() => {
          return this.printOptions("gridLines") && this.printOptions("gridLinesSet");
        }).case(["nil"], () => {
          this.printOptions("gridLines", void 0);
          this.printOptions("gridLinesSet", void 0);
          return this;
        }).case(["boolean"], (enabled) => {
          this.printOptions("gridLines", enabled);
          this.printOptions("gridLinesSet", enabled);
          return this;
        }).handle(arguments);
      }
      /**
       * Get the page margin given a valid attribute name.
       * If the value is not yet defined, then it will return the current preset value.
       * @param {string} attributeName - Attribute name of the pageMargins.
       *     left - Left Page Margin in inches.
       *     right - Right page margin in inches.
       *     top - Top Page Margin in inches.
       *     buttom - Bottom Page Margin in inches.
       *     footer - Footer Page Margin in inches.
       *     header - Header Page Margin in inches.
       * @returns {number} the attribute value.
       */
      /**
      * Set the page margin (or override the preset) given an attribute name and a value.
      * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.
      * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.
      * @returns {Sheet} The sheet.
      */
      pageMargins() {
        if (this.pageMarginsPreset() === void 0) {
          throw new Error("Sheet.pageMargins: preset is undefined.");
        }
        const supportedAttributeNames = [
          "left",
          "right",
          "top",
          "bottom",
          "header",
          "footer"
        ];
        const checkAttributeName = this._getCheckAttributeNameHelper("pageMargins", supportedAttributeNames);
        const checkRange = this._getCheckRangeHelper("pageMargins", 0, void 0);
        return new ArgHandler("Sheet.pageMargins").case(["string"], (attributeName) => {
          checkAttributeName(attributeName);
          const attributeValue = this._pageMarginsNode.attributes[attributeName];
          if (attributeValue !== void 0) {
            return parseFloat(attributeValue);
          } else if (this._pageMarginsPresetName) {
            return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);
          } else {
            return void 0;
          }
        }).case(["string", "nil"], (attributeName) => {
          checkAttributeName(attributeName);
          delete this._pageMarginsNode.attributes[attributeName];
          return this;
        }).case(["string", "number"], (attributeName, attributeNumberValue) => {
          checkAttributeName(attributeName);
          checkRange(attributeNumberValue);
          this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;
          return this;
        }).case(["string", "string"], (attributeName, attributeStringValue) => {
          return this.pageMargins(attributeName, parseFloat(attributeStringValue));
        }).handle(arguments);
      }
      /**
       * Page margins preset is a set of page margins associated with a name.
       * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.
       * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.
       * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.
       * Available presets include: normal, wide, narrow, template.
       *
       * Get the page margins preset name. The registered name of a predefined set of attributes.
       * @returns {string} The preset name.
       */
      /**
      * Set the page margins preset by name, clearing any existing/temporary attribute values.
      * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.
      * @returns {Sheet} The sheet.
      */
      /**
      * Set a new page margins preset by name and attributes object.
      * @param {string} presetName - The preset name.
      * @param {object} presetAttributes - The preset attributes.
      * @returns {Sheet} The sheet.
      */
      pageMarginsPreset() {
        return new ArgHandler("Sheet.pageMarginsPreset").case(() => {
          return this._pageMarginsPresetName;
        }).case(["nil"], () => {
          this._pageMarginsPresetName = void 0;
          this._pageMarginsNode.attributes = {};
          return this;
        }).case(["string"], (presetName) => {
          const checkPresetName = this._getCheckAttributeNameHelper(
            "pageMarginsPreset",
            Object.keys(this._pageMarginsPresets)
          );
          checkPresetName(presetName);
          this._pageMarginsPresetName = presetName;
          this._pageMarginsNode.attributes = {};
          return this;
        }).case(["string", "object"], (presetName, presetAttributes) => {
          if (this._pageMarginsPresets.hasOwnProperty(presetName)) {
            throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);
          }
          const pageMarginsAttributeNames = [
            "left",
            "right",
            "top",
            "bottom",
            "header",
            "footer"
          ];
          const isValidPresetAttributeKeys = _.isEqual(
            _.sortBy(pageMarginsAttributeNames),
            _.sortBy(Object.keys(presetAttributes))
          );
          if (isValidPresetAttributeKeys === false) {
            throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - "${Object.keys(presetAttributes)}"`);
          }
          _.forEach((attributeValue, attributeName) => {
            const attributeNumberValue = parseFloat(attributeValue);
            if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {
              throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - "${attributeValue}"`);
            }
          });
          this._pageMarginsPresetName = presetName;
          this._pageMarginsNode.attributes = {};
          this._pageMarginsPresets[presetName] = presetAttributes;
          return this;
        }).handle(arguments);
      }
      /**
       * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1
       * @typedef {Object} PaneOptions
       * @property {string} activePane=bottomRight Active Pane. The pane that is active.
       * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,
       * and whether those splits are frozen.
       * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom
       * right pane (when in Left-To-Right mode).
       * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;
       * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.
       * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0
       * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.
       */
      /**
      * Gets sheet view pane options
      * @return {PaneOptions} sheet view pane options
      */
      /**
      * Sets sheet view pane options
      * @param {PaneOptions|null|undefined} paneOptions sheet view pane options
      * @return {Sheet} The sheet
      */
      panes() {
        const supportedStates = ["split", "frozen", "frozenSplit"];
        const supportedActivePanes = ["bottomLeft", "bottomRight", "topLeft", "topRight"];
        const checkStateName = this._getCheckAttributeNameHelper("pane.state", supportedStates);
        const checkActivePane = this._getCheckAttributeNameHelper("pane.activePane", supportedActivePanes);
        const sheetViewNode = this._getOrCreateSheetViewNode();
        let paneNode = xmlq.findChild(sheetViewNode, "pane");
        return new ArgHandler("Sheet.pane").case(() => {
          if (paneNode) {
            const result = _.cloneDeep(paneNode.attributes);
            if (!result.state)
              result.state = "split";
            return result;
          }
        }).case(["nil"], () => {
          xmlq.removeChild(sheetViewNode, "pane");
          return this;
        }).case(["object"], (paneAttributes) => {
          const attributes = _.assign({ activePane: "bottomRight" }, paneAttributes);
          checkStateName(attributes.state);
          checkActivePane(attributes.activePane);
          if (paneNode) {
            paneNode.attributes = attributes;
          } else {
            paneNode = {
              name: "pane",
              attributes,
              children: []
            };
            xmlq.appendChild(sheetViewNode, paneNode);
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Freezes Panes for this sheet.
       * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.
       * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.
       * @return {Sheet} The sheet
       */
      /**
      * freezes Panes for this sheet.
      * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom
      * right pane (when in Left-To-Right mode).
      * @return {Sheet} The sheet
      */
      freezePanes() {
        return new ArgHandler("Sheet.feezePanes").case(["integer", "integer"], (xSplit, ySplit) => {
          const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);
          let activePane = xSplit === 0 ? "bottomLeft" : "bottomRight";
          activePane = ySplit === 0 ? "topRight" : activePane;
          return this.panes({ state: "frozen", topLeftCell, xSplit, ySplit, activePane });
        }).case(["string"], (topLeftCell) => {
          const ref = addressConverter.fromAddress(topLeftCell);
          const xSplit = ref.columnNumber - 1, ySplit = ref.rowNumber - 1;
          let activePane = xSplit === 0 ? "bottomLeft" : "bottomRight";
          activePane = ySplit === 0 ? "topRight" : activePane;
          return this.panes({ state: "frozen", topLeftCell, xSplit, ySplit, activePane });
        }).handle(arguments);
      }
      /**
       * Splits Panes for this sheet.
       * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,
       * in 1/20th of a point; 0 (zero) if none.
       * @param {number} ySplit (Vertical Split Position) VVertical position of the split,
       * in 1/20th of a point; 0 (zero) if none.
       * @return {Sheet} The sheet
       */
      splitPanes(xSplit, ySplit) {
        return this.panes({ state: "split", xSplit, ySplit });
      }
      /**
       * resets to default sheet view panes.
       * @return {Sheet} The sheet
       */
      resetPanes() {
        return this.panes(null);
      }
      /* PRIVATE */
      /**
       * Get a helper function to check that the attribute name provided is supported.
       * @param {string} functionName - Name of the parent function.
       * @param {array} supportedAttributeNames - Array of supported attribute name strings.
       * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.
       * @ignore
       */
      _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {
        return (attributeName) => {
          if (!_.includes(supportedAttributeNames, attributeName)) {
            throw new Error(`Sheet.${functionName}: "${attributeName}" is not supported.`);
          }
        };
      }
      /**
       * Get a helper function to check that the value is of the expected type.
       * @param {string} functionName - Name of the parent function.
       * @param {string} valueType - A string produced by typeof.
       * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.
       * @ignore
       */
      _getCheckTypeHelper(functionName, valueType) {
        return (value) => {
          if (typeof value !== valueType) {
            throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);
          }
        };
      }
      /**
       * Get a helper function to check that the value is within the expected range.
       * @param {string} functionName - Name of the parent function.
       * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.
       * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.
       * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.
       * @ignore
       */
      _getCheckRangeHelper(functionName, valueMin, valueMax) {
        const checkType = this._getCheckTypeHelper(functionName, "number");
        return (value) => {
          checkType(value);
          if (valueMin !== void 0) {
            if (value < valueMin) {
              throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);
            }
          }
          if (valueMax !== void 0) {
            if (valueMax <= value) {
              throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);
            }
          }
        };
      }
      /**
       * Get the sheet view node if it exists or create it if it doesn't.
       * @returns {{}} The sheet view node.
       * @private
       */
      _getOrCreateSheetViewNode() {
        let sheetViewsNode = xmlq.findChild(this._node, "sheetViews");
        if (!sheetViewsNode) {
          sheetViewsNode = {
            name: "sheetViews",
            attributes: {},
            children: [{
              name: "sheetView",
              attributes: {
                workbookViewId: 0
              },
              children: []
            }]
          };
          xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);
        }
        return xmlq.findChild(sheetViewsNode, "sheetView");
      }
      /**
       * Initializes the sheet.
       * @param {Workbook} workbook - The parent workbook.
       * @param {{}} idNode - The sheet ID node (from the parent workbook).
       * @param {{}} node - The sheet node.
       * @param {{}} [relationshipsNode] - The optional sheet relationships node.
       * @returns {undefined}
       * @private
       */
      _init(workbook, idNode, node, relationshipsNode) {
        if (!node) {
          node = {
            name: "worksheet",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
              "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
              "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
              "mc:Ignorable": "x14ac",
              "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"
            },
            children: [{
              name: "sheetData",
              attributes: {},
              children: []
            }]
          };
        }
        this._workbook = workbook;
        this._idNode = idNode;
        this._node = node;
        this._maxSharedFormulaId = -1;
        this._mergeCells = {};
        this._dataValidations = {};
        this._hyperlinks = {};
        this._autoFilter = null;
        this._relationships = new Relationships(relationshipsNode);
        xmlq.removeChild(this._node, "dimension");
        this._rows = [];
        this._sheetDataNode = xmlq.findChild(this._node, "sheetData");
        this._sheetDataNode.children.forEach((rowNode) => {
          const row = new Row(this, rowNode);
          this._rows[row.rowNumber()] = row;
        });
        this._sheetDataNode.children = this._rows;
        this._columns = [];
        this._colsNode = xmlq.findChild(this._node, "cols");
        if (this._colsNode) {
          xmlq.removeChild(this._node, this._colsNode);
        } else {
          this._colsNode = { name: "cols", attributes: {}, children: [] };
        }
        this._colNodes = [];
        _.forEach(this._colsNode.children, (colNode) => {
          const min = colNode.attributes.min;
          const max = colNode.attributes.max;
          for (let i = min; i <= max; i++) {
            this._colNodes[i] = colNode;
          }
        });
        this._sheetPrNode = xmlq.findChild(this._node, "sheetPr");
        if (!this._sheetPrNode) {
          this._sheetPrNode = { name: "sheetPr", attributes: {}, children: [] };
          xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);
        }
        this._mergeCellsNode = xmlq.findChild(this._node, "mergeCells");
        if (this._mergeCellsNode) {
          xmlq.removeChild(this._node, this._mergeCellsNode);
        } else {
          this._mergeCellsNode = { name: "mergeCells", attributes: {}, children: [] };
        }
        const mergeCellNodes = this._mergeCellsNode.children;
        this._mergeCellsNode.children = [];
        mergeCellNodes.forEach((mergeCellNode) => {
          this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;
        });
        this._dataValidationsNode = xmlq.findChild(this._node, "dataValidations");
        if (this._dataValidationsNode) {
          xmlq.removeChild(this._node, this._dataValidationsNode);
        } else {
          this._dataValidationsNode = { name: "dataValidations", attributes: {}, children: [] };
        }
        const dataValidationNodes = this._dataValidationsNode.children;
        this._dataValidationsNode.children = [];
        dataValidationNodes.forEach((dataValidationNode) => {
          this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;
        });
        this._hyperlinksNode = xmlq.findChild(this._node, "hyperlinks");
        if (this._hyperlinksNode) {
          xmlq.removeChild(this._node, this._hyperlinksNode);
        } else {
          this._hyperlinksNode = { name: "hyperlinks", attributes: {}, children: [] };
        }
        const hyperlinkNodes = this._hyperlinksNode.children;
        this._hyperlinksNode.children = [];
        hyperlinkNodes.forEach((hyperlinkNode) => {
          this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;
        });
        this._printOptionsNode = xmlq.findChild(this._node, "printOptions");
        if (this._printOptionsNode) {
          xmlq.removeChild(this._node, this._printOptionsNode);
        } else {
          this._printOptionsNode = { name: "printOptions", attributes: {}, children: [] };
        }
        this._pageMarginsPresets = {
          normal: {
            left: 0.7,
            right: 0.7,
            top: 0.75,
            bottom: 0.75,
            header: 0.3,
            footer: 0.3
          },
          wide: {
            left: 1,
            right: 1,
            top: 1,
            bottom: 1,
            header: 0.5,
            footer: 0.5
          },
          narrow: {
            left: 0.25,
            right: 0.25,
            top: 0.75,
            bottom: 0.75,
            header: 0.3,
            footer: 0.3
          }
        };
        this._pageMarginsNode = xmlq.findChild(this._node, "pageMargins");
        if (this._pageMarginsNode) {
          this._pageMarginsPresetName = "template";
          for (const presetName in this._pageMarginsPresets) {
            if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {
              this._pageMarginsPresetName = presetName;
              break;
            }
          }
          if (this._pageMarginsPresetName === "template") {
            this._pageMarginsPresets.template = this._pageMarginsNode.attributes;
            this._pageMarginsNode.attributes = {};
          }
          xmlq.removeChild(this._node, this._pageMarginsNode);
        } else {
          this._pageMarginsPresetName = void 0;
          this._pageMarginsNode = { name: "pageMargins", attributes: {}, children: [] };
        }
        ["colBreaks", "rowBreaks"].forEach((name) => {
          this[`_${name}Node`] = xmlq.findChild(this._node, name);
          if (this[`_${name}Node`]) {
            xmlq.removeChild(this._node, this[`_${name}Node`]);
          } else {
            this[`_${name}Node`] = {
              name,
              children: [],
              attributes: {
                count: 0,
                manualBreakCount: 0
              }
            };
          }
        });
        this._pageBreaks = {
          colBreaks: new PageBreaks(this._colBreaksNode),
          rowBreaks: new PageBreaks(this._rowBreaksNode)
        };
      }
    };
    module.exports = Sheet;
  }
});

// node_modules/xlsx-populate/lib/ContentTypes.js
var require_ContentTypes = __commonJS({
  "node_modules/xlsx-populate/lib/ContentTypes.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var ContentTypes = class {
      /**
       * Creates a new instance of ContentTypes
       * @param {{}} node - The node.
       */
      constructor(node) {
        this._node = node;
      }
      /**
       * Add a new content type.
       * @param {string} partName - The part name.
       * @param {string} contentType - The content type.
       * @returns {{}} The new content type.
       */
      add(partName, contentType) {
        const node = {
          name: "Override",
          attributes: {
            PartName: partName,
            ContentType: contentType
          }
        };
        this._node.children.push(node);
        return node;
      }
      /**
       * Find a content type by part name.
       * @param {string} partName - The part name.
       * @returns {{}|undefined} The matching content type or undefined if not found.
       */
      findByPartName(partName) {
        return _.find(this._node.children, (node) => node.attributes.PartName === partName);
      }
      /**
       * Convert the collection to an XML object.
       * @returns {{}} The XML.
       */
      toXml() {
        return this._node;
      }
    };
    module.exports = ContentTypes;
  }
});

// node_modules/xlsx-populate/lib/AppProperties.js
var require_AppProperties = __commonJS({
  "node_modules/xlsx-populate/lib/AppProperties.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var xmlq = require_xmlq();
    var ArgHandler = require_ArgHandler();
    var AppProperties = class {
      /**
       * Creates a new instance of AppProperties
       * @param {{}} node - The node.
       */
      constructor(node) {
        this._node = node;
      }
      isSecure(value) {
        return new ArgHandler("Range.formula").case(() => {
          const docSecurityNode = xmlq.findChild(this._node, "DocSecurity");
          if (!docSecurityNode)
            return false;
          return docSecurityNode.children[0] === 1;
        }).case("boolean", (value2) => {
          const docSecurityNode = xmlq.appendChildIfNotFound(this._node, "DocSecurity");
          docSecurityNode.children = [value2 ? 1 : 0];
          return this;
        }).handle(arguments);
      }
      /**
       * Convert the collection to an XML object.
       * @returns {{}} The XML.
       */
      toXml() {
        return this._node;
      }
    };
    module.exports = AppProperties;
  }
});

// node_modules/xlsx-populate/lib/CoreProperties.js
var require_CoreProperties = __commonJS({
  "node_modules/xlsx-populate/lib/CoreProperties.js"(exports, module) {
    "use strict";
    var allowedProperties = {
      title: "dc:title",
      subject: "dc:subject",
      author: "dc:creator",
      creator: "dc:creator",
      description: "dc:description",
      keywords: "cp:keywords",
      category: "cp:category"
    };
    var CoreProperties = class {
      constructor(node) {
        this._node = node;
        this._properties = {};
      }
      /**
       * Sets a specific property.
       * @param {string} name - The name of the property.
       * @param {*} value - The value of the property.
       * @returns {CoreProperties} CoreProperties.
       */
      set(name, value) {
        const key = name.toLowerCase();
        if (typeof allowedProperties[key] === "undefined") {
          throw new Error(`Unknown property name: "${name}"`);
        }
        this._properties[key] = value;
        return this;
      }
      /**
       * Get a specific property.
       * @param {string} name - The name of the property.
       * @returns {*} The property value.
       */
      get(name) {
        const key = name.toLowerCase();
        if (typeof allowedProperties[key] === "undefined") {
          throw new Error(`Unknown property name: "${name}"`);
        }
        return this._properties[key];
      }
      /**
       * Convert the collection to an XML object.
       * @returns {{}} The XML.
       */
      toXml() {
        for (const key in this._properties) {
          if (!this._properties.hasOwnProperty(key))
            continue;
          this._node.children.push({
            name: allowedProperties[key],
            children: [this._properties[key]]
          });
        }
        return this._node;
      }
    };
    module.exports = CoreProperties;
  }
});

// node_modules/xlsx-populate/lib/SharedStrings.js
var require_SharedStrings = __commonJS({
  "node_modules/xlsx-populate/lib/SharedStrings.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var SharedStrings = class {
      /**
       * Constructs a new instance of _SharedStrings.
       * @param {{}} node - The node.
       */
      constructor(node) {
        this._stringArray = [];
        this._indexMap = {};
        this._init(node);
        this._cacheExistingSharedStrings();
      }
      /**
       * Gets the index for a string
       * @param {string|Array.<{}>} string - The string or rich text array.
       * @returns {number} The index
       */
      getIndexForString(string) {
        const key = _.isArray(string) ? JSON.stringify(string) : string;
        let index = this._indexMap[key];
        if (index >= 0)
          return index;
        index = this._stringArray.length;
        this._stringArray.push(string);
        this._indexMap[key] = index;
        this._node.children.push({
          name: "si",
          children: _.isArray(string) ? string : [
            {
              name: "t",
              attributes: { "xml:space": "preserve" },
              children: [string]
            }
          ]
        });
        return index;
      }
      /**
       * Get the string for a given index
       * @param {number} index - The index
       * @returns {string} The string
       */
      getStringByIndex(index) {
        return this._stringArray[index];
      }
      /**
       * Convert the collection to an XML object.
       * @returns {{}} The XML object.
       */
      toXml() {
        return this._node;
      }
      /**
       * Store any existing values in the caches.
       * @private
       * @returns {undefined}
       */
      _cacheExistingSharedStrings() {
        this._node.children.forEach((node, i) => {
          const content = node.children[0];
          if (content.name === "t") {
            const string = content.children[0];
            this._stringArray.push(string);
            this._indexMap[string] = i;
          } else {
            this._stringArray.push(node.children);
            this._indexMap[JSON.stringify(node.children)] = i;
          }
        });
      }
      /**
       * Initialize the node.
       * @param {{}} [node] - The shared strings node.
       * @private
       * @returns {undefined}
       */
      _init(node) {
        if (!node)
          node = {
            name: "sst",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
            },
            children: []
          };
        this._node = node;
        delete this._node.attributes.count;
        delete this._node.attributes.uniqueCount;
      }
    };
    module.exports = SharedStrings;
  }
});

// node_modules/xlsx-populate/lib/StyleSheet.js
var require_StyleSheet = __commonJS({
  "node_modules/xlsx-populate/lib/StyleSheet.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var xmlq = require_xmlq();
    var Style = require_Style();
    var STANDARD_CODES = {
      0: "General",
      1: "0",
      2: "0.00",
      3: "#,##0",
      4: "#,##0.00",
      9: "0%",
      10: "0.00%",
      11: "0.00E+00",
      12: "# ?/?",
      13: "# ??/??",
      14: "mm-dd-yy",
      15: "d-mmm-yy",
      16: "d-mmm",
      17: "mmm-yy",
      18: "h:mm AM/PM",
      19: "h:mm:ss AM/PM",
      20: "h:mm",
      21: "h:mm:ss",
      22: "m/d/yy h:mm",
      37: "#,##0 ;(#,##0)",
      38: "#,##0 ;[Red](#,##0)",
      39: "#,##0.00;(#,##0.00)",
      40: "#,##0.00;[Red](#,##0.00)",
      45: "mm:ss",
      46: "[h]:mm:ss",
      47: "mmss.0",
      48: "##0.0E+0",
      49: "@"
    };
    var STARTING_CUSTOM_NUMBER_FORMAT_ID = 164;
    var StyleSheet = class {
      /**
       * Creates an instance of _StyleSheet.
       * @param {string} node - The style sheet node
       */
      constructor(node) {
        this._init(node);
        this._cacheNumberFormats();
      }
      /**
       * Create a style.
       * @param {number} [sourceId] - The source style ID to copy, if provided.
       * @returns {Style} The style.
       */
      createStyle(sourceId) {
        let fontNode, fillNode, borderNode, xfNode;
        if (sourceId >= 0) {
          const sourceXfNode = this._cellXfsNode.children[sourceId];
          xfNode = _.cloneDeep(sourceXfNode);
          if (sourceXfNode.attributes.applyFont) {
            const fontId = sourceXfNode.attributes.fontId;
            fontNode = _.cloneDeep(this._fontsNode.children[fontId]);
          }
          if (sourceXfNode.attributes.applyFill) {
            const fillId = sourceXfNode.attributes.fillId;
            fillNode = _.cloneDeep(this._fillsNode.children[fillId]);
          }
          if (sourceXfNode.attributes.applyBorder) {
            const borderId = sourceXfNode.attributes.borderId;
            borderNode = _.cloneDeep(this._bordersNode.children[borderId]);
          }
        }
        if (!fontNode)
          fontNode = { name: "font", attributes: {}, children: [] };
        this._fontsNode.children.push(fontNode);
        if (!fillNode)
          fillNode = { name: "fill", attributes: {}, children: [] };
        this._fillsNode.children.push(fillNode);
        if (!borderNode)
          borderNode = { name: "border", attributes: {}, children: [] };
        borderNode.children = [
          xmlq.findChild(borderNode, "left") || { name: "left", attributes: {}, children: [] },
          xmlq.findChild(borderNode, "right") || { name: "right", attributes: {}, children: [] },
          xmlq.findChild(borderNode, "top") || { name: "top", attributes: {}, children: [] },
          xmlq.findChild(borderNode, "bottom") || { name: "bottom", attributes: {}, children: [] },
          xmlq.findChild(borderNode, "diagonal") || { name: "diagonal", attributes: {}, children: [] }
        ];
        this._bordersNode.children.push(borderNode);
        if (!xfNode)
          xfNode = { name: "xf", attributes: {}, children: [] };
        _.assign(xfNode.attributes, {
          fontId: this._fontsNode.children.length - 1,
          fillId: this._fillsNode.children.length - 1,
          borderId: this._bordersNode.children.length - 1,
          applyFont: 1,
          applyFill: 1,
          applyBorder: 1
        });
        this._cellXfsNode.children.push(xfNode);
        return new Style(this, this._cellXfsNode.children.length - 1, xfNode, fontNode, fillNode, borderNode);
      }
      /**
       * Get the number format code for a given ID.
       * @param {number} id - The number format ID.
       * @returns {string} The format code.
       */
      getNumberFormatCode(id) {
        return this._numberFormatCodesById[id];
      }
      /**
       * Get the nuumber format ID for a given code.
       * @param {string} code - The format code.
       * @returns {number} The number format ID.
       */
      getNumberFormatId(code) {
        let id = this._numberFormatIdsByCode[code];
        if (id === void 0) {
          id = this._nextNumFormatId++;
          this._numberFormatCodesById[id] = code;
          this._numberFormatIdsByCode[code] = id;
          this._numFmtsNode.children.push({
            name: "numFmt",
            attributes: {
              numFmtId: id,
              formatCode: code
            }
          });
        }
        return id;
      }
      /**
       * Convert the style sheet to an XML object.
       * @returns {{}} The XML form.
       * @ignore
       */
      toXml() {
        return this._node;
      }
      /**
       * Cache the number format codes
       * @returns {undefined}
       * @private
       */
      _cacheNumberFormats() {
        this._numberFormatCodesById = {};
        this._numberFormatIdsByCode = {};
        for (const id in STANDARD_CODES) {
          if (!STANDARD_CODES.hasOwnProperty(id))
            continue;
          const code = STANDARD_CODES[id];
          this._numberFormatCodesById[id] = code;
          this._numberFormatIdsByCode[code] = parseInt(id);
        }
        this._nextNumFormatId = STARTING_CUSTOM_NUMBER_FORMAT_ID;
        this._numFmtsNode.children.forEach((node) => {
          const id = node.attributes.numFmtId;
          const code = node.attributes.formatCode;
          this._numberFormatCodesById[id] = code;
          this._numberFormatIdsByCode[code] = id;
          if (id >= this._nextNumFormatId)
            this._nextNumFormatId = id + 1;
        });
      }
      /**
       * Initialize the style sheet node.
       * @param {{}} [node] - The node
       * @returns {undefined}
       * @private
       */
      _init(node) {
        this._node = node;
        this._numFmtsNode = xmlq.findChild(this._node, "numFmts");
        this._fontsNode = xmlq.findChild(this._node, "fonts");
        this._fillsNode = xmlq.findChild(this._node, "fills");
        this._bordersNode = xmlq.findChild(this._node, "borders");
        this._cellXfsNode = xmlq.findChild(this._node, "cellXfs");
        if (!this._numFmtsNode) {
          this._numFmtsNode = {
            name: "numFmts",
            attributes: {},
            children: []
          };
          xmlq.insertBefore(this._node, this._numFmtsNode, this._fontsNode);
        }
        delete this._numFmtsNode.attributes.count;
        delete this._fontsNode.attributes.count;
        delete this._fillsNode.attributes.count;
        delete this._bordersNode.attributes.count;
        delete this._cellXfsNode.attributes.count;
      }
    };
    module.exports = StyleSheet;
  }
});

// node_modules/cfb/cfb.js
var require_cfb = __commonJS({
  "node_modules/cfb/cfb.js"(exports, module) {
    var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function Base64_encode(input) {
      var o = "";
      var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
      for (var i = 0; i < input.length; ) {
        c1 = input.charCodeAt(i++);
        e1 = c1 >> 2;
        c2 = input.charCodeAt(i++);
        e2 = (c1 & 3) << 4 | c2 >> 4;
        c3 = input.charCodeAt(i++);
        e3 = (c2 & 15) << 2 | c3 >> 6;
        e4 = c3 & 63;
        if (isNaN(c2))
          e3 = e4 = 64;
        else if (isNaN(c3))
          e4 = 64;
        o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
      }
      return o;
    }
    function Base64_decode(input) {
      var o = "";
      var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
      input = input.replace(/[^\w\+\/\=]/g, "");
      for (var i = 0; i < input.length; ) {
        e1 = Base64_map.indexOf(input.charAt(i++));
        e2 = Base64_map.indexOf(input.charAt(i++));
        c1 = e1 << 2 | e2 >> 4;
        o += String.fromCharCode(c1);
        e3 = Base64_map.indexOf(input.charAt(i++));
        c2 = (e2 & 15) << 4 | e3 >> 2;
        if (e3 !== 64)
          o += String.fromCharCode(c2);
        e4 = Base64_map.indexOf(input.charAt(i++));
        c3 = (e3 & 3) << 6 | e4;
        if (e4 !== 64)
          o += String.fromCharCode(c3);
      }
      return o;
    }
    var has_buf = function() {
      return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
    }();
    var Buffer_from = function() {
      if (typeof Buffer !== "undefined") {
        var nbfs = !Buffer.from;
        if (!nbfs)
          try {
            Buffer.from("foo", "utf8");
          } catch (e) {
            nbfs = true;
          }
        return nbfs ? function(buf, enc) {
          return enc ? new Buffer(buf, enc) : new Buffer(buf);
        } : Buffer.from.bind(Buffer);
      }
      return function() {
      };
    }();
    function new_raw_buf(len) {
      if (has_buf) {
        if (Buffer.alloc)
          return Buffer.alloc(len);
        var b = new Buffer(len);
        b.fill(0);
        return b;
      }
      return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
    }
    function new_unsafe_buf(len) {
      if (has_buf)
        return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
      return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
    }
    var s2a = function s2a2(s) {
      if (has_buf)
        return Buffer_from(s, "binary");
      return s.split("").map(function(x) {
        return x.charCodeAt(0) & 255;
      });
    };
    var chr0 = /\u0000/g;
    var chr1 = /[\u0001-\u0006]/g;
    var __toBuffer = function(bufs) {
      var x = [];
      for (var i = 0; i < bufs[0].length; ++i) {
        x.push.apply(x, bufs[0][i]);
      }
      return x;
    };
    var ___toBuffer = __toBuffer;
    var __utf16le = function(b, s, e) {
      var ss = [];
      for (var i = s; i < e; i += 2)
        ss.push(String.fromCharCode(__readUInt16LE(b, i)));
      return ss.join("").replace(chr0, "");
    };
    var ___utf16le = __utf16le;
    var __hexlify = function(b, s, l) {
      var ss = [];
      for (var i = s; i < s + l; ++i)
        ss.push(("0" + b[i].toString(16)).slice(-2));
      return ss.join("");
    };
    var ___hexlify = __hexlify;
    var __bconcat = function(bufs) {
      if (Array.isArray(bufs[0]))
        return [].concat.apply([], bufs);
      var maxlen = 0, i = 0;
      for (i = 0; i < bufs.length; ++i)
        maxlen += bufs[i].length;
      var o = new Uint8Array(maxlen);
      for (i = 0, maxlen = 0; i < bufs.length; maxlen += bufs[i].length, ++i)
        o.set(bufs[i], maxlen);
      return o;
    };
    var bconcat = __bconcat;
    if (has_buf) {
      __utf16le = function(b, s, e) {
        if (!Buffer.isBuffer(b))
          return ___utf16le(b, s, e);
        return b.toString("utf16le", s, e).replace(chr0, "");
      };
      __hexlify = function(b, s, l) {
        return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
      };
      __toBuffer = function(bufs) {
        return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);
      };
      s2a = function(s) {
        return Buffer_from(s, "binary");
      };
      bconcat = function(bufs) {
        return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : __bconcat(bufs);
      };
    }
    var __readUInt8 = function(b, idx) {
      return b[idx];
    };
    var __readUInt16LE = function(b, idx) {
      return b[idx + 1] * (1 << 8) + b[idx];
    };
    var __readInt16LE = function(b, idx) {
      var u = b[idx + 1] * (1 << 8) + b[idx];
      return u < 32768 ? u : (65535 - u + 1) * -1;
    };
    var __readUInt32LE = function(b, idx) {
      return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
    };
    var __readInt32LE = function(b, idx) {
      return (b[idx + 3] << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
    };
    function ReadShift(size, t) {
      var oI, oS, type = 0;
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          break;
        case 2:
          oI = (t !== "i" ? __readUInt16LE : __readInt16LE)(this, this.l);
          break;
        case 4:
          oI = __readInt32LE(this, this.l);
          break;
        case 16:
          type = 2;
          oS = __hexlify(this, this.l, size);
      }
      this.l += size;
      if (type === 0)
        return oI;
      return oS;
    }
    var __writeUInt32LE = function(b, val, idx) {
      b[idx] = val & 255;
      b[idx + 1] = val >>> 8 & 255;
      b[idx + 2] = val >>> 16 & 255;
      b[idx + 3] = val >>> 24 & 255;
    };
    var __writeInt32LE = function(b, val, idx) {
      b[idx] = val & 255;
      b[idx + 1] = val >> 8 & 255;
      b[idx + 2] = val >> 16 & 255;
      b[idx + 3] = val >> 24 & 255;
    };
    function WriteShift(t, val, f) {
      var size = 0, i = 0;
      switch (f) {
        case "hex":
          for (; i < t; ++i) {
            this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
          }
          return this;
        case "utf16le":
          var end = this.l + t;
          for (i = 0; i < Math.min(val.length, t); ++i) {
            var cc = val.charCodeAt(i);
            this[this.l++] = cc & 255;
            this[this.l++] = cc >> 8;
          }
          while (this.l < end)
            this[this.l++] = 0;
          return this;
      }
      switch (t) {
        case 1:
          size = 1;
          this[this.l] = val & 255;
          break;
        case 2:
          size = 2;
          this[this.l] = val & 255;
          val >>>= 8;
          this[this.l + 1] = val & 255;
          break;
        case 4:
          size = 4;
          __writeUInt32LE(this, val, this.l);
          break;
        case -4:
          size = 4;
          __writeInt32LE(this, val, this.l);
          break;
      }
      this.l += size;
      return this;
    }
    function CheckField(hexstr, fld) {
      var m = __hexlify(this, this.l, hexstr.length >> 1);
      if (m !== hexstr)
        throw new Error(fld + "Expected " + hexstr + " saw " + m);
      this.l += hexstr.length >> 1;
    }
    function prep_blob(blob, pos) {
      blob.l = pos;
      blob.read_shift = ReadShift;
      blob.chk = CheckField;
      blob.write_shift = WriteShift;
    }
    function new_buf(sz) {
      var o = new_raw_buf(sz);
      prep_blob(o, 0);
      return o;
    }
    var CRC32 = function() {
      var CRC322 = {};
      CRC322.version = "1.2.1";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
      return CRC322;
    }();
    var CFB = function _CFB() {
      var exports2 = {};
      exports2.version = "1.2.2";
      function namecmp(l, r) {
        var L = l.split("/"), R = r.split("/");
        for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
          if (c = L[i2].length - R[i2].length)
            return c;
          if (L[i2] != R[i2])
            return L[i2] < R[i2] ? -1 : 1;
        }
        return L.length - R.length;
      }
      function dirname(p) {
        if (p.charAt(p.length - 1) == "/")
          return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
        var c = p.lastIndexOf("/");
        return c === -1 ? p : p.slice(0, c + 1);
      }
      function filename(p) {
        if (p.charAt(p.length - 1) == "/")
          return filename(p.slice(0, -1));
        var c = p.lastIndexOf("/");
        return c === -1 ? p : p.slice(c + 1);
      }
      function write_dos_date(buf, date) {
        if (typeof date === "string")
          date = new Date(date);
        var hms = date.getHours();
        hms = hms << 6 | date.getMinutes();
        hms = hms << 5 | date.getSeconds() >>> 1;
        buf.write_shift(2, hms);
        var ymd = date.getFullYear() - 1980;
        ymd = ymd << 4 | date.getMonth() + 1;
        ymd = ymd << 5 | date.getDate();
        buf.write_shift(2, ymd);
      }
      function parse_dos_date(buf) {
        var hms = buf.read_shift(2) & 65535;
        var ymd = buf.read_shift(2) & 65535;
        var val = /* @__PURE__ */ new Date();
        var d = ymd & 31;
        ymd >>>= 5;
        var m = ymd & 15;
        ymd >>>= 4;
        val.setMilliseconds(0);
        val.setFullYear(ymd + 1980);
        val.setMonth(m - 1);
        val.setDate(d);
        var S = hms & 31;
        hms >>>= 5;
        var M = hms & 63;
        hms >>>= 6;
        val.setHours(hms);
        val.setMinutes(M);
        val.setSeconds(S << 1);
        return val;
      }
      function parse_extra_field(blob) {
        prep_blob(blob, 0);
        var o = {};
        var flags = 0;
        while (blob.l <= blob.length - 4) {
          var type = blob.read_shift(2);
          var sz = blob.read_shift(2), tgt = blob.l + sz;
          var p = {};
          switch (type) {
            case 21589:
              {
                flags = blob.read_shift(1);
                if (flags & 1)
                  p.mtime = blob.read_shift(4);
                if (sz > 5) {
                  if (flags & 2)
                    p.atime = blob.read_shift(4);
                  if (flags & 4)
                    p.ctime = blob.read_shift(4);
                }
                if (p.mtime)
                  p.mt = new Date(p.mtime * 1e3);
              }
              break;
          }
          blob.l = tgt;
          o[type] = p;
        }
        return o;
      }
      var fs;
      function get_fs() {
        return fs || (fs = require_fs());
      }
      function parse(file, options) {
        if (file[0] == 80 && file[1] == 75)
          return parse_zip(file, options);
        if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
          return parse_mad(file, options);
        if (file.length < 512)
          throw new Error("CFB file size " + file.length + " < 512");
        var mver = 3;
        var ssz = 512;
        var nmfs = 0;
        var difat_sec_cnt = 0;
        var dir_start = 0;
        var minifat_start = 0;
        var difat_start = 0;
        var fat_addrs = [];
        var blob = file.slice(0, 512);
        prep_blob(blob, 0);
        var mv = check_get_mver(blob);
        mver = mv[0];
        switch (mver) {
          case 3:
            ssz = 512;
            break;
          case 4:
            ssz = 4096;
            break;
          case 0:
            if (mv[1] == 0)
              return parse_zip(file, options);
          default:
            throw new Error("Major Version: Expected 3 or 4 saw " + mver);
        }
        if (ssz !== 512) {
          blob = file.slice(0, ssz);
          prep_blob(
            blob,
            28
            /* blob.l */
          );
        }
        var header = file.slice(0, ssz);
        check_shifts(blob, mver);
        var dir_cnt = blob.read_shift(4, "i");
        if (mver === 3 && dir_cnt !== 0)
          throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
        blob.l += 4;
        dir_start = blob.read_shift(4, "i");
        blob.l += 4;
        blob.chk("00100000", "Mini Stream Cutoff Size: ");
        minifat_start = blob.read_shift(4, "i");
        nmfs = blob.read_shift(4, "i");
        difat_start = blob.read_shift(4, "i");
        difat_sec_cnt = blob.read_shift(4, "i");
        for (var q2 = -1, j = 0; j < 109; ++j) {
          q2 = blob.read_shift(4, "i");
          if (q2 < 0)
            break;
          fat_addrs[j] = q2;
        }
        var sectors = sectorify(file, ssz);
        sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
        var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
        sector_list[dir_start].name = "!Directory";
        if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
          sector_list[minifat_start].name = "!MiniFAT";
        sector_list[fat_addrs[0]].name = "!FAT";
        sector_list.fat_addrs = fat_addrs;
        sector_list.ssz = ssz;
        var files = {}, Paths = [], FileIndex = [], FullPaths = [];
        read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
        build_full_paths(FileIndex, FullPaths, Paths);
        Paths.shift();
        var o = {
          FileIndex,
          FullPaths
        };
        if (options && options.raw)
          o.raw = { header, sectors };
        return o;
      }
      function check_get_mver(blob) {
        if (blob[blob.l] == 80 && blob[blob.l + 1] == 75)
          return [0, 0];
        blob.chk(HEADER_SIGNATURE, "Header Signature: ");
        blob.l += 16;
        var mver = blob.read_shift(2, "u");
        return [blob.read_shift(2, "u"), mver];
      }
      function check_shifts(blob, mver) {
        var shift = 9;
        blob.l += 2;
        switch (shift = blob.read_shift(2)) {
          case 9:
            if (mver != 3)
              throw new Error("Sector Shift: Expected 9 saw " + shift);
            break;
          case 12:
            if (mver != 4)
              throw new Error("Sector Shift: Expected 12 saw " + shift);
            break;
          default:
            throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
        }
        blob.chk("0600", "Mini Sector Shift: ");
        blob.chk("000000000000", "Reserved: ");
      }
      function sectorify(file, ssz) {
        var nsectors = Math.ceil(file.length / ssz) - 1;
        var sectors = [];
        for (var i2 = 1; i2 < nsectors; ++i2)
          sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
        sectors[nsectors - 1] = file.slice(nsectors * ssz);
        return sectors;
      }
      function build_full_paths(FI, FP, Paths) {
        var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
        var dad = [], q2 = [];
        for (; i2 < pl; ++i2) {
          dad[i2] = q2[i2] = i2;
          FP[i2] = Paths[i2];
        }
        for (; j < q2.length; ++j) {
          i2 = q2[j];
          L = FI[i2].L;
          R = FI[i2].R;
          C = FI[i2].C;
          if (dad[i2] === i2) {
            if (L !== -1 && dad[L] !== L)
              dad[i2] = dad[L];
            if (R !== -1 && dad[R] !== R)
              dad[i2] = dad[R];
          }
          if (C !== -1)
            dad[C] = i2;
          if (L !== -1 && i2 != dad[i2]) {
            dad[L] = dad[i2];
            if (q2.lastIndexOf(L) < j)
              q2.push(L);
          }
          if (R !== -1 && i2 != dad[i2]) {
            dad[R] = dad[i2];
            if (q2.lastIndexOf(R) < j)
              q2.push(R);
          }
        }
        for (i2 = 1; i2 < pl; ++i2)
          if (dad[i2] === i2) {
            if (R !== -1 && dad[R] !== R)
              dad[i2] = dad[R];
            else if (L !== -1 && dad[L] !== L)
              dad[i2] = dad[L];
          }
        for (i2 = 1; i2 < pl; ++i2) {
          if (FI[i2].type === 0)
            continue;
          j = i2;
          if (j != dad[j])
            do {
              j = dad[j];
              FP[i2] = FP[j] + "/" + FP[i2];
            } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
          dad[i2] = -1;
        }
        FP[0] += "/";
        for (i2 = 1; i2 < pl; ++i2) {
          if (FI[i2].type !== 2)
            FP[i2] += "/";
        }
      }
      function get_mfat_entry(entry, payload, mini) {
        var start = entry.start, size = entry.size;
        var o = [];
        var idx = start;
        while (mini && size > 0 && idx >= 0) {
          o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
          size -= MSSZ;
          idx = __readInt32LE(mini, idx * 4);
        }
        if (o.length === 0)
          return new_buf(0);
        return bconcat(o).slice(0, entry.size);
      }
      function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
        var q2 = ENDOFCHAIN;
        if (idx === ENDOFCHAIN) {
          if (cnt !== 0)
            throw new Error("DIFAT chain shorter than expected");
        } else if (idx !== -1) {
          var sector = sectors[idx], m = (ssz >>> 2) - 1;
          if (!sector)
            return;
          for (var i2 = 0; i2 < m; ++i2) {
            if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN)
              break;
            fat_addrs.push(q2);
          }
          if (cnt >= 1)
            sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
        }
      }
      function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
        var buf = [], buf_chain = [];
        if (!chkd)
          chkd = [];
        var modulus = ssz - 1, j = 0, jj = 0;
        for (j = start; j >= 0; ) {
          chkd[j] = true;
          buf[buf.length] = j;
          buf_chain.push(sectors[j]);
          var addr = fat_addrs[Math.floor(j * 4 / ssz)];
          jj = j * 4 & modulus;
          if (ssz < 4 + jj)
            throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
          if (!sectors[addr])
            break;
          j = __readInt32LE(sectors[addr], jj);
        }
        return { nodes: buf, data: __toBuffer([buf_chain]) };
      }
      function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
        var sl = sectors.length, sector_list = [];
        var chkd = [], buf = [], buf_chain = [];
        var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
        for (i2 = 0; i2 < sl; ++i2) {
          buf = [];
          k = i2 + dir_start;
          if (k >= sl)
            k -= sl;
          if (chkd[k])
            continue;
          buf_chain = [];
          var seen = [];
          for (j = k; j >= 0; ) {
            seen[j] = true;
            chkd[j] = true;
            buf[buf.length] = j;
            buf_chain.push(sectors[j]);
            var addr = fat_addrs[Math.floor(j * 4 / ssz)];
            jj = j * 4 & modulus;
            if (ssz < 4 + jj)
              throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
            if (!sectors[addr])
              break;
            j = __readInt32LE(sectors[addr], jj);
            if (seen[j])
              break;
          }
          sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
        }
        return sector_list;
      }
      function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
        var minifat_store = 0, pl = Paths.length ? 2 : 0;
        var sector = sector_list[dir_start].data;
        var i2 = 0, namelen = 0, name;
        for (; i2 < sector.length; i2 += 128) {
          var blob = sector.slice(i2, i2 + 128);
          prep_blob(blob, 64);
          namelen = blob.read_shift(2);
          name = __utf16le(blob, 0, namelen - pl);
          Paths.push(name);
          var o = {
            name,
            type: blob.read_shift(1),
            color: blob.read_shift(1),
            L: blob.read_shift(4, "i"),
            R: blob.read_shift(4, "i"),
            C: blob.read_shift(4, "i"),
            clsid: blob.read_shift(16),
            state: blob.read_shift(4, "i"),
            start: 0,
            size: 0
          };
          var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
          if (ctime !== 0)
            o.ct = read_date(blob, blob.l - 8);
          var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
          if (mtime !== 0)
            o.mt = read_date(blob, blob.l - 8);
          o.start = blob.read_shift(4, "i");
          o.size = blob.read_shift(4, "i");
          if (o.size < 0 && o.start < 0) {
            o.size = o.type = 0;
            o.start = ENDOFCHAIN;
            o.name = "";
          }
          if (o.type === 5) {
            minifat_store = o.start;
            if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
              sector_list[minifat_store].name = "!StreamData";
          } else if (o.size >= 4096) {
            o.storage = "fat";
            if (sector_list[o.start] === void 0)
              sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
            sector_list[o.start].name = o.name;
            o.content = sector_list[o.start].data.slice(0, o.size);
          } else {
            o.storage = "minifat";
            if (o.size < 0)
              o.size = 0;
            else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
              o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
            }
          }
          if (o.content)
            prep_blob(o.content, 0);
          files[name] = o;
          FileIndex.push(o);
        }
      }
      function read_date(blob, offset) {
        return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
      }
      function read_file(filename2, options) {
        get_fs();
        return parse(fs.readFileSync(filename2), options);
      }
      function read(blob, options) {
        var type = options && options.type;
        if (!type) {
          if (has_buf && Buffer.isBuffer(blob))
            type = "buffer";
        }
        switch (type || "base64") {
          case "file":
            return read_file(blob, options);
          case "base64":
            return parse(s2a(Base64_decode(blob)), options);
          case "binary":
            return parse(s2a(blob), options);
        }
        return parse(blob, options);
      }
      function init_cfb(cfb, opts) {
        var o = opts || {}, root = o.root || "Root Entry";
        if (!cfb.FullPaths)
          cfb.FullPaths = [];
        if (!cfb.FileIndex)
          cfb.FileIndex = [];
        if (cfb.FullPaths.length !== cfb.FileIndex.length)
          throw new Error("inconsistent CFB structure");
        if (cfb.FullPaths.length === 0) {
          cfb.FullPaths[0] = root + "/";
          cfb.FileIndex[0] = { name: root, type: 5 };
        }
        if (o.CLSID)
          cfb.FileIndex[0].clsid = o.CLSID;
        seed_cfb(cfb);
      }
      function seed_cfb(cfb) {
        var nm = "Sh33tJ5";
        if (CFB.find(cfb, "/" + nm))
          return;
        var p = new_buf(4);
        p[0] = 55;
        p[1] = p[3] = 50;
        p[2] = 54;
        cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
        cfb.FullPaths.push(cfb.FullPaths[0] + nm);
        rebuild_cfb(cfb);
      }
      function rebuild_cfb(cfb, f) {
        init_cfb(cfb);
        var gc = false, s = false;
        for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
          var _file = cfb.FileIndex[i2];
          switch (_file.type) {
            case 0:
              if (s)
                gc = true;
              else {
                cfb.FileIndex.pop();
                cfb.FullPaths.pop();
              }
              break;
            case 1:
            case 2:
            case 5:
              s = true;
              if (isNaN(_file.R * _file.L * _file.C))
                gc = true;
              if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
                gc = true;
              break;
            default:
              gc = true;
              break;
          }
        }
        if (!gc && !f)
          return;
        var now = new Date(1987, 1, 19), j = 0;
        var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
        var data = [];
        for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
          fullPaths[cfb.FullPaths[i2]] = true;
          if (cfb.FileIndex[i2].type === 0)
            continue;
          data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
        }
        for (i2 = 0; i2 < data.length; ++i2) {
          var dad = dirname(data[i2][0]);
          s = fullPaths[dad];
          while (!s) {
            while (dirname(dad) && !fullPaths[dirname(dad)])
              dad = dirname(dad);
            data.push([dad, {
              name: filename(dad).replace("/", ""),
              type: 1,
              clsid: HEADER_CLSID,
              ct: now,
              mt: now,
              content: null
            }]);
            fullPaths[dad] = true;
            dad = dirname(data[i2][0]);
            s = fullPaths[dad];
          }
        }
        data.sort(function(x, y) {
          return namecmp(x[0], y[0]);
        });
        cfb.FullPaths = [];
        cfb.FileIndex = [];
        for (i2 = 0; i2 < data.length; ++i2) {
          cfb.FullPaths[i2] = data[i2][0];
          cfb.FileIndex[i2] = data[i2][1];
        }
        for (i2 = 0; i2 < data.length; ++i2) {
          var elt = cfb.FileIndex[i2];
          var nm = cfb.FullPaths[i2];
          elt.name = filename(nm).replace("/", "");
          elt.L = elt.R = elt.C = -(elt.color = 1);
          elt.size = elt.content ? elt.content.length : 0;
          elt.start = 0;
          elt.clsid = elt.clsid || HEADER_CLSID;
          if (i2 === 0) {
            elt.C = data.length > 1 ? 1 : -1;
            elt.size = 0;
            elt.type = 5;
          } else if (nm.slice(-1) == "/") {
            for (j = i2 + 1; j < data.length; ++j)
              if (dirname(cfb.FullPaths[j]) == nm)
                break;
            elt.C = j >= data.length ? -1 : j;
            for (j = i2 + 1; j < data.length; ++j)
              if (dirname(cfb.FullPaths[j]) == dirname(nm))
                break;
            elt.R = j >= data.length ? -1 : j;
            elt.type = 1;
          } else {
            if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm))
              elt.R = i2 + 1;
            elt.type = 2;
          }
        }
      }
      function _write(cfb, options) {
        var _opts = options || {};
        if (_opts.fileType == "mad")
          return write_mad(cfb, _opts);
        rebuild_cfb(cfb);
        switch (_opts.fileType) {
          case "zip":
            return write_zip(cfb, _opts);
        }
        var L = function(cfb2) {
          var mini_size = 0, fat_size = 0;
          for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
            var file2 = cfb2.FileIndex[i3];
            if (!file2.content)
              continue;
            var flen2 = file2.content.length;
            if (flen2 > 0) {
              if (flen2 < 4096)
                mini_size += flen2 + 63 >> 6;
              else
                fat_size += flen2 + 511 >> 9;
            }
          }
          var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
          var mini_cnt = mini_size + 7 >> 3;
          var mfat_cnt = mini_size + 127 >> 7;
          var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
          var fat_cnt = fat_base + 127 >> 7;
          var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
          while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
            difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
          var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
          cfb2.FileIndex[0].size = mini_size << 6;
          L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
          return L2;
        }(cfb);
        var o = new_buf(L[7] << 9);
        var i2 = 0, T = 0;
        {
          for (i2 = 0; i2 < 8; ++i2)
            o.write_shift(1, HEADER_SIG[i2]);
          for (i2 = 0; i2 < 8; ++i2)
            o.write_shift(2, 0);
          o.write_shift(2, 62);
          o.write_shift(2, 3);
          o.write_shift(2, 65534);
          o.write_shift(2, 9);
          o.write_shift(2, 6);
          for (i2 = 0; i2 < 3; ++i2)
            o.write_shift(2, 0);
          o.write_shift(4, 0);
          o.write_shift(4, L[2]);
          o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
          o.write_shift(4, 0);
          o.write_shift(4, 1 << 12);
          o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
          o.write_shift(4, L[3]);
          o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
          o.write_shift(4, L[1]);
          for (i2 = 0; i2 < 109; ++i2)
            o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
        }
        if (L[1]) {
          for (T = 0; T < L[1]; ++T) {
            for (; i2 < 236 + T * 127; ++i2)
              o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
            o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
          }
        }
        var chainit = function(w) {
          for (T += w; i2 < T - 1; ++i2)
            o.write_shift(-4, i2 + 1);
          if (w) {
            ++i2;
            o.write_shift(-4, ENDOFCHAIN);
          }
        };
        T = i2 = 0;
        for (T += L[1]; i2 < T; ++i2)
          o.write_shift(-4, consts.DIFSECT);
        for (T += L[2]; i2 < T; ++i2)
          o.write_shift(-4, consts.FATSECT);
        chainit(L[3]);
        chainit(L[4]);
        var j = 0, flen = 0;
        var file = cfb.FileIndex[0];
        for (; j < cfb.FileIndex.length; ++j) {
          file = cfb.FileIndex[j];
          if (!file.content)
            continue;
          flen = file.content.length;
          if (flen < 4096)
            continue;
          file.start = T;
          chainit(flen + 511 >> 9);
        }
        chainit(L[6] + 7 >> 3);
        while (o.l & 511)
          o.write_shift(-4, consts.ENDOFCHAIN);
        T = i2 = 0;
        for (j = 0; j < cfb.FileIndex.length; ++j) {
          file = cfb.FileIndex[j];
          if (!file.content)
            continue;
          flen = file.content.length;
          if (!flen || flen >= 4096)
            continue;
          file.start = T;
          chainit(flen + 63 >> 6);
        }
        while (o.l & 511)
          o.write_shift(-4, consts.ENDOFCHAIN);
        for (i2 = 0; i2 < L[4] << 2; ++i2) {
          var nm = cfb.FullPaths[i2];
          if (!nm || nm.length === 0) {
            for (j = 0; j < 17; ++j)
              o.write_shift(4, 0);
            for (j = 0; j < 3; ++j)
              o.write_shift(4, -1);
            for (j = 0; j < 12; ++j)
              o.write_shift(4, 0);
            continue;
          }
          file = cfb.FileIndex[i2];
          if (i2 === 0)
            file.start = file.size ? file.start - 1 : ENDOFCHAIN;
          var _nm = i2 === 0 && _opts.root || file.name;
          if (_nm.length > 32) {
            console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 32));
            _nm = _nm.slice(0, 32);
          }
          flen = 2 * (_nm.length + 1);
          o.write_shift(64, _nm, "utf16le");
          o.write_shift(2, flen);
          o.write_shift(1, file.type);
          o.write_shift(1, file.color);
          o.write_shift(-4, file.L);
          o.write_shift(-4, file.R);
          o.write_shift(-4, file.C);
          if (!file.clsid)
            for (j = 0; j < 4; ++j)
              o.write_shift(4, 0);
          else
            o.write_shift(16, file.clsid, "hex");
          o.write_shift(4, file.state || 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, 0);
          o.write_shift(4, file.start);
          o.write_shift(4, file.size);
          o.write_shift(4, 0);
        }
        for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
          file = cfb.FileIndex[i2];
          if (file.size >= 4096) {
            o.l = file.start + 1 << 9;
            if (has_buf && Buffer.isBuffer(file.content)) {
              file.content.copy(o, o.l, 0, file.size);
              o.l += file.size + 511 & -512;
            } else {
              for (j = 0; j < file.size; ++j)
                o.write_shift(1, file.content[j]);
              for (; j & 511; ++j)
                o.write_shift(1, 0);
            }
          }
        }
        for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
          file = cfb.FileIndex[i2];
          if (file.size > 0 && file.size < 4096) {
            if (has_buf && Buffer.isBuffer(file.content)) {
              file.content.copy(o, o.l, 0, file.size);
              o.l += file.size + 63 & -64;
            } else {
              for (j = 0; j < file.size; ++j)
                o.write_shift(1, file.content[j]);
              for (; j & 63; ++j)
                o.write_shift(1, 0);
            }
          }
        }
        if (has_buf) {
          o.l = o.length;
        } else {
          while (o.l < o.length)
            o.write_shift(1, 0);
        }
        return o;
      }
      function find(cfb, path) {
        var UCFullPaths = cfb.FullPaths.map(function(x) {
          return x.toUpperCase();
        });
        var UCPaths = UCFullPaths.map(function(x) {
          var y = x.split("/");
          return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
        });
        var k = false;
        if (path.charCodeAt(0) === 47) {
          k = true;
          path = UCFullPaths[0].slice(0, -1) + path;
        } else
          k = path.indexOf("/") !== -1;
        var UCPath = path.toUpperCase();
        var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
        if (w !== -1)
          return cfb.FileIndex[w];
        var m = !UCPath.match(chr1);
        UCPath = UCPath.replace(chr0, "");
        if (m)
          UCPath = UCPath.replace(chr1, "!");
        for (w = 0; w < UCFullPaths.length; ++w) {
          if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath)
            return cfb.FileIndex[w];
          if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath)
            return cfb.FileIndex[w];
        }
        return null;
      }
      var MSSZ = 64;
      var ENDOFCHAIN = -2;
      var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
      var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
      var HEADER_CLSID = "00000000000000000000000000000000";
      var consts = {
        /* 2.1 Compund File Sector Numbers and Types */
        MAXREGSECT: -6,
        DIFSECT: -4,
        FATSECT: -3,
        ENDOFCHAIN,
        FREESECT: -1,
        /* 2.2 Compound File Header */
        HEADER_SIGNATURE,
        HEADER_MINOR_VERSION: "3e00",
        MAXREGSID: -6,
        NOSTREAM: -1,
        HEADER_CLSID,
        /* 2.6.1 Compound File Directory Entry */
        EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
      };
      function write_file(cfb, filename2, options) {
        get_fs();
        var o = _write(cfb, options);
        fs.writeFileSync(filename2, o);
      }
      function a2s(o) {
        var out = new Array(o.length);
        for (var i2 = 0; i2 < o.length; ++i2)
          out[i2] = String.fromCharCode(o[i2]);
        return out.join("");
      }
      function write(cfb, options) {
        var o = _write(cfb, options);
        switch (options && options.type || "buffer") {
          case "file":
            get_fs();
            fs.writeFileSync(options.filename, o);
            return o;
          case "binary":
            return typeof o == "string" ? o : a2s(o);
          case "base64":
            return Base64_encode(typeof o == "string" ? o : a2s(o));
          case "buffer":
            if (has_buf)
              return Buffer.isBuffer(o) ? o : Buffer_from(o);
          case "array":
            return typeof o == "string" ? s2a(o) : o;
        }
        return o;
      }
      var _zlib;
      function use_zlib(zlib) {
        try {
          var InflateRaw = zlib.InflateRaw;
          var InflRaw = new InflateRaw();
          InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
          if (InflRaw.bytesRead)
            _zlib = zlib;
          else
            throw new Error("zlib does not expose bytesRead");
        } catch (e) {
          console.error("cannot use native zlib: " + (e.message || e));
        }
      }
      function _inflateRawSync(payload, usz) {
        if (!_zlib)
          return _inflate(payload, usz);
        var InflateRaw = _zlib.InflateRaw;
        var InflRaw = new InflateRaw();
        var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
        payload.l += InflRaw.bytesRead;
        return out;
      }
      function _deflateRawSync(payload) {
        return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
      }
      var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
      var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
      function bit_swap_8(n) {
        var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
        return (t >> 16 | t >> 8 | t) & 255;
      }
      var use_typed_arrays = typeof Uint8Array !== "undefined";
      var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
      for (var q = 0; q < 1 << 8; ++q)
        bitswap8[q] = bit_swap_8(q);
      function bit_swap_n(n, b) {
        var rev = bitswap8[n & 255];
        if (b <= 8)
          return rev >>> 8 - b;
        rev = rev << 8 | bitswap8[n >> 8 & 255];
        if (b <= 16)
          return rev >>> 16 - b;
        rev = rev << 8 | bitswap8[n >> 16 & 255];
        return rev >>> 24 - b;
      }
      function read_bits_2(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 3;
      }
      function read_bits_3(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 7;
      }
      function read_bits_4(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 15;
      }
      function read_bits_5(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 31;
      }
      function read_bits_7(buf, bl) {
        var w = bl & 7, h = bl >>> 3;
        return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 127;
      }
      function read_bits_n(buf, bl, n) {
        var w = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
        var v = buf[h] >>> w;
        if (n < 8 - w)
          return v & f;
        v |= buf[h + 1] << 8 - w;
        if (n < 16 - w)
          return v & f;
        v |= buf[h + 2] << 16 - w;
        if (n < 24 - w)
          return v & f;
        v |= buf[h + 3] << 24 - w;
        return v & f;
      }
      function write_bits_3(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        if (w <= 5)
          buf[h] |= (v & 7) << w;
        else {
          buf[h] |= v << w & 255;
          buf[h + 1] = (v & 7) >> 8 - w;
        }
        return bl + 3;
      }
      function write_bits_1(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v = (v & 1) << w;
        buf[h] |= v;
        return bl + 1;
      }
      function write_bits_8(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v <<= w;
        buf[h] |= v & 255;
        v >>>= 8;
        buf[h + 1] = v;
        return bl + 8;
      }
      function write_bits_16(buf, bl, v) {
        var w = bl & 7, h = bl >>> 3;
        v <<= w;
        buf[h] |= v & 255;
        v >>>= 8;
        buf[h + 1] = v & 255;
        buf[h + 2] = v >>> 8;
        return bl + 16;
      }
      function realloc(b, sz) {
        var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
        if (L >= sz)
          return b;
        if (has_buf) {
          var o = new_unsafe_buf(M);
          if (b.copy)
            b.copy(o);
          else
            for (; i2 < b.length; ++i2)
              o[i2] = b[i2];
          return o;
        } else if (use_typed_arrays) {
          var a = new Uint8Array(M);
          if (a.set)
            a.set(b);
          else
            for (; i2 < L; ++i2)
              a[i2] = b[i2];
          return a;
        }
        b.length = M;
        return b;
      }
      function zero_fill_array(n) {
        var o = new Array(n);
        for (var i2 = 0; i2 < n; ++i2)
          o[i2] = 0;
        return o;
      }
      function build_tree(clens, cmap, MAX) {
        var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
        var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
        for (i2 = 0; i2 < 32; ++i2)
          bl_count[i2] = 0;
        for (i2 = L; i2 < MAX; ++i2)
          clens[i2] = 0;
        L = clens.length;
        var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
        for (i2 = 0; i2 < L; ++i2) {
          bl_count[w = clens[i2]]++;
          if (maxlen < w)
            maxlen = w;
          ctree[i2] = 0;
        }
        bl_count[0] = 0;
        for (i2 = 1; i2 <= maxlen; ++i2)
          bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
        for (i2 = 0; i2 < L; ++i2) {
          ccode = clens[i2];
          if (ccode != 0)
            ctree[i2] = bl_count[ccode + 16]++;
        }
        var cleni = 0;
        for (i2 = 0; i2 < L; ++i2) {
          cleni = clens[i2];
          if (cleni != 0) {
            ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
            for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
              cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
          }
        }
        return maxlen;
      }
      var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
      var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
      if (!use_typed_arrays) {
        for (var i = 0; i < 512; ++i)
          fix_lmap[i] = 0;
        for (i = 0; i < 32; ++i)
          fix_dmap[i] = 0;
      }
      (function() {
        var dlens = [];
        var i2 = 0;
        for (; i2 < 32; i2++)
          dlens.push(5);
        build_tree(dlens, fix_dmap, 32);
        var clens = [];
        i2 = 0;
        for (; i2 <= 143; i2++)
          clens.push(8);
        for (; i2 <= 255; i2++)
          clens.push(9);
        for (; i2 <= 279; i2++)
          clens.push(7);
        for (; i2 <= 287; i2++)
          clens.push(8);
        build_tree(clens, fix_lmap, 288);
      })();
      var _deflateRaw = function _deflateRawIIFE() {
        var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
        var j = 0, k = 0;
        for (; j < DST_LN.length - 1; ++j) {
          for (; k < DST_LN[j + 1]; ++k)
            DST_LN_RE[k] = j;
        }
        for (; k < 32768; ++k)
          DST_LN_RE[k] = 29;
        var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
        for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
          for (; k < LEN_LN[j + 1]; ++k)
            LEN_LN_RE[k] = j;
        }
        function write_stored(data, out) {
          var boff = 0;
          while (boff < data.length) {
            var L = Math.min(65535, data.length - boff);
            var h = boff + L == data.length;
            out.write_shift(1, +h);
            out.write_shift(2, L);
            out.write_shift(2, ~L & 65535);
            while (L-- > 0)
              out[out.l++] = data[boff++];
          }
          return out.l;
        }
        function write_huff_fixed(data, out) {
          var bl = 0;
          var boff = 0;
          var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
          while (boff < data.length) {
            var L = (
              /* data.length - boff; */
              Math.min(65535, data.length - boff)
            );
            if (L < 10) {
              bl = write_bits_3(out, bl, +!!(boff + L == data.length));
              if (bl & 7)
                bl += 8 - (bl & 7);
              out.l = bl / 8 | 0;
              out.write_shift(2, L);
              out.write_shift(2, ~L & 65535);
              while (L-- > 0)
                out[out.l++] = data[boff++];
              bl = out.l * 8;
              continue;
            }
            bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
            var hash = 0;
            while (L-- > 0) {
              var d = data[boff];
              hash = (hash << 5 ^ d) & 32767;
              var match = -1, mlen = 0;
              if (match = addrs[hash]) {
                match |= boff & ~32767;
                if (match > boff)
                  match -= 32768;
                if (match < boff)
                  while (data[match + mlen] == data[boff + mlen] && mlen < 250)
                    ++mlen;
              }
              if (mlen > 2) {
                d = LEN_LN_RE[mlen];
                if (d <= 22)
                  bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
                else {
                  write_bits_8(out, bl, 3);
                  bl += 5;
                  write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                  bl += 3;
                }
                var len_eb = d < 8 ? 0 : d - 4 >> 2;
                if (len_eb > 0) {
                  write_bits_16(out, bl, mlen - LEN_LN[d]);
                  bl += len_eb;
                }
                d = DST_LN_RE[boff - match];
                bl = write_bits_8(out, bl, bitswap8[d] >> 3);
                bl -= 3;
                var dst_eb = d < 4 ? 0 : d - 2 >> 1;
                if (dst_eb > 0) {
                  write_bits_16(out, bl, boff - match - DST_LN[d]);
                  bl += dst_eb;
                }
                for (var q2 = 0; q2 < mlen; ++q2) {
                  addrs[hash] = boff & 32767;
                  hash = (hash << 5 ^ data[boff]) & 32767;
                  ++boff;
                }
                L -= mlen - 1;
              } else {
                if (d <= 143)
                  d = d + 48;
                else
                  bl = write_bits_1(out, bl, 1);
                bl = write_bits_8(out, bl, bitswap8[d]);
                addrs[hash] = boff & 32767;
                ++boff;
              }
            }
            bl = write_bits_8(out, bl, 0) - 1;
          }
          out.l = (bl + 7) / 8 | 0;
          return out.l;
        }
        return function _deflateRaw2(data, out) {
          if (data.length < 8)
            return write_stored(data, out);
          return write_huff_fixed(data, out);
        };
      }();
      function _deflate(data) {
        var buf = new_buf(50 + Math.floor(data.length * 1.1));
        var off = _deflateRaw(data, buf);
        return buf.slice(0, off);
      }
      var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
      var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
      var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
      var dyn_len_1 = 1, dyn_len_2 = 1;
      function dyn(data, boff) {
        var _HLIT = read_bits_5(data, boff) + 257;
        boff += 5;
        var _HDIST = read_bits_5(data, boff) + 1;
        boff += 5;
        var _HCLEN = read_bits_4(data, boff) + 4;
        boff += 4;
        var w = 0;
        var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
        var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var maxlen = 1;
        var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
        var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
        var L = clens.length;
        for (var i2 = 0; i2 < _HCLEN; ++i2) {
          clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
          if (maxlen < w)
            maxlen = w;
          bl_count[w]++;
          boff += 3;
        }
        var ccode = 0;
        bl_count[0] = 0;
        for (i2 = 1; i2 <= maxlen; ++i2)
          next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
        for (i2 = 0; i2 < L; ++i2)
          if ((ccode = clens[i2]) != 0)
            ctree[i2] = next_code[ccode]++;
        var cleni = 0;
        for (i2 = 0; i2 < L; ++i2) {
          cleni = clens[i2];
          if (cleni != 0) {
            ccode = bitswap8[ctree[i2]] >> 8 - cleni;
            for (var j = (1 << 7 - cleni) - 1; j >= 0; --j)
              dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
          }
        }
        var hcodes = [];
        maxlen = 1;
        for (; hcodes.length < _HLIT + _HDIST; ) {
          ccode = dyn_cmap[read_bits_7(data, boff)];
          boff += ccode & 7;
          switch (ccode >>>= 3) {
            case 16:
              w = 3 + read_bits_2(data, boff);
              boff += 2;
              ccode = hcodes[hcodes.length - 1];
              while (w-- > 0)
                hcodes.push(ccode);
              break;
            case 17:
              w = 3 + read_bits_3(data, boff);
              boff += 3;
              while (w-- > 0)
                hcodes.push(0);
              break;
            case 18:
              w = 11 + read_bits_7(data, boff);
              boff += 7;
              while (w-- > 0)
                hcodes.push(0);
              break;
            default:
              hcodes.push(ccode);
              if (maxlen < ccode)
                maxlen = ccode;
              break;
          }
        }
        var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
        for (i2 = _HLIT; i2 < 286; ++i2)
          h1[i2] = 0;
        for (i2 = _HDIST; i2 < 30; ++i2)
          h2[i2] = 0;
        dyn_len_1 = build_tree(h1, dyn_lmap, 286);
        dyn_len_2 = build_tree(h2, dyn_dmap, 30);
        return boff;
      }
      function inflate(data, usz) {
        if (data[0] == 3 && !(data[1] & 3)) {
          return [new_raw_buf(usz), 2];
        }
        var boff = 0;
        var header = 0;
        var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
        var woff = 0;
        var OL = outbuf.length >>> 0;
        var max_len_1 = 0, max_len_2 = 0;
        while ((header & 1) == 0) {
          header = read_bits_3(data, boff);
          boff += 3;
          if (header >>> 1 == 0) {
            if (boff & 7)
              boff += 8 - (boff & 7);
            var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
            boff += 32;
            if (sz > 0) {
              if (!usz && OL < woff + sz) {
                outbuf = realloc(outbuf, woff + sz);
                OL = outbuf.length;
              }
              while (sz-- > 0) {
                outbuf[woff++] = data[boff >>> 3];
                boff += 8;
              }
            }
            continue;
          } else if (header >> 1 == 1) {
            max_len_1 = 9;
            max_len_2 = 5;
          } else {
            boff = dyn(data, boff);
            max_len_1 = dyn_len_1;
            max_len_2 = dyn_len_2;
          }
          for (; ; ) {
            if (!usz && OL < woff + 32767) {
              outbuf = realloc(outbuf, woff + 32767);
              OL = outbuf.length;
            }
            var bits = read_bits_n(data, boff, max_len_1);
            var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
            boff += code & 15;
            code >>>= 4;
            if ((code >>> 8 & 255) === 0)
              outbuf[woff++] = code;
            else if (code == 256)
              break;
            else {
              code -= 257;
              var len_eb = code < 8 ? 0 : code - 4 >> 2;
              if (len_eb > 5)
                len_eb = 0;
              var tgt = woff + LEN_LN[code];
              if (len_eb > 0) {
                tgt += read_bits_n(data, boff, len_eb);
                boff += len_eb;
              }
              bits = read_bits_n(data, boff, max_len_2);
              code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
              boff += code & 15;
              code >>>= 4;
              var dst_eb = code < 4 ? 0 : code - 2 >> 1;
              var dst = DST_LN[code];
              if (dst_eb > 0) {
                dst += read_bits_n(data, boff, dst_eb);
                boff += dst_eb;
              }
              if (!usz && OL < tgt) {
                outbuf = realloc(outbuf, tgt + 100);
                OL = outbuf.length;
              }
              while (woff < tgt) {
                outbuf[woff] = outbuf[woff - dst];
                ++woff;
              }
            }
          }
        }
        if (usz)
          return [outbuf, boff + 7 >>> 3];
        return [outbuf.slice(0, woff), boff + 7 >>> 3];
      }
      function _inflate(payload, usz) {
        var data = payload.slice(payload.l || 0);
        var out = inflate(data, usz);
        payload.l += out[1];
        return out[0];
      }
      function warn_or_throw(wrn, msg) {
        if (wrn) {
          if (typeof console !== "undefined")
            console.error(msg);
        } else
          throw new Error(msg);
      }
      function parse_zip(file, options) {
        var blob = file;
        prep_blob(blob, 0);
        var FileIndex = [], FullPaths = [];
        var o = {
          FileIndex,
          FullPaths
        };
        init_cfb(o, { root: options.root });
        var i2 = blob.length - 4;
        while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0)
          --i2;
        blob.l = i2 + 4;
        blob.l += 4;
        var fcnt = blob.read_shift(2);
        blob.l += 6;
        var start_cd = blob.read_shift(4);
        blob.l = start_cd;
        for (i2 = 0; i2 < fcnt; ++i2) {
          blob.l += 20;
          var csz = blob.read_shift(4);
          var usz = blob.read_shift(4);
          var namelen = blob.read_shift(2);
          var efsz = blob.read_shift(2);
          var fcsz = blob.read_shift(2);
          blob.l += 8;
          var offset = blob.read_shift(4);
          var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));
          blob.l += namelen + efsz + fcsz;
          var L = blob.l;
          blob.l = offset + 4;
          parse_local_file(blob, csz, usz, o, EF);
          blob.l = L;
        }
        return o;
      }
      function parse_local_file(blob, csz, usz, o, EF) {
        blob.l += 2;
        var flags = blob.read_shift(2);
        var meth = blob.read_shift(2);
        var date = parse_dos_date(blob);
        if (flags & 8257)
          throw new Error("Unsupported ZIP encryption");
        var crc32 = blob.read_shift(4);
        var _csz = blob.read_shift(4);
        var _usz = blob.read_shift(4);
        var namelen = blob.read_shift(2);
        var efsz = blob.read_shift(2);
        var name = "";
        for (var i2 = 0; i2 < namelen; ++i2)
          name += String.fromCharCode(blob[blob.l++]);
        if (efsz) {
          var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));
          if ((ef[21589] || {}).mt)
            date = ef[21589].mt;
          if (((EF || {})[21589] || {}).mt)
            date = EF[21589].mt;
        }
        blob.l += efsz;
        var data = blob.slice(blob.l, blob.l + _csz);
        switch (meth) {
          case 8:
            data = _inflateRawSync(blob, _usz);
            break;
          case 0:
            break;
          default:
            throw new Error("Unsupported ZIP Compression method " + meth);
        }
        var wrn = false;
        if (flags & 8) {
          crc32 = blob.read_shift(4);
          if (crc32 == 134695760) {
            crc32 = blob.read_shift(4);
            wrn = true;
          }
          _csz = blob.read_shift(4);
          _usz = blob.read_shift(4);
        }
        if (_csz != csz)
          warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
        if (_usz != usz)
          warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
        var _crc32 = CRC32.buf(data, 0);
        if (crc32 >> 0 != _crc32 >> 0)
          warn_or_throw(wrn, "Bad CRC32 checksum: " + crc32 + " != " + _crc32);
        cfb_add(o, name, data, { unsafe: true, mt: date });
      }
      function write_zip(cfb, options) {
        var _opts = options || {};
        var out = [], cdirs = [];
        var o = new_buf(1);
        var method = _opts.compression ? 8 : 0, flags = 0;
        var desc = false;
        if (desc)
          flags |= 8;
        var i2 = 0, j = 0;
        var start_cd = 0, fcnt = 0;
        var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
        var crcs = [];
        var sz_cd = 0;
        for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
          fp = cfb.FullPaths[i2].slice(root.length);
          fi = cfb.FileIndex[i2];
          if (!fi.size || !fi.content || fp == "Sh33tJ5")
            continue;
          var start = start_cd;
          var namebuf = new_buf(fp.length);
          for (j = 0; j < fp.length; ++j)
            namebuf.write_shift(1, fp.charCodeAt(j) & 127);
          namebuf = namebuf.slice(0, namebuf.l);
          crcs[fcnt] = CRC32.buf(fi.content, 0);
          var outbuf = fi.content;
          if (method == 8)
            outbuf = _deflateRawSync(outbuf);
          o = new_buf(30);
          o.write_shift(4, 67324752);
          o.write_shift(2, 20);
          o.write_shift(2, flags);
          o.write_shift(2, method);
          if (fi.mt)
            write_dos_date(o, fi.mt);
          else
            o.write_shift(4, 0);
          o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);
          o.write_shift(4, flags & 8 ? 0 : outbuf.length);
          o.write_shift(4, flags & 8 ? 0 : fi.content.length);
          o.write_shift(2, namebuf.length);
          o.write_shift(2, 0);
          start_cd += o.length;
          out.push(o);
          start_cd += namebuf.length;
          out.push(namebuf);
          start_cd += outbuf.length;
          out.push(outbuf);
          if (flags & 8) {
            o = new_buf(12);
            o.write_shift(-4, crcs[fcnt]);
            o.write_shift(4, outbuf.length);
            o.write_shift(4, fi.content.length);
            start_cd += o.l;
            out.push(o);
          }
          o = new_buf(46);
          o.write_shift(4, 33639248);
          o.write_shift(2, 0);
          o.write_shift(2, 20);
          o.write_shift(2, flags);
          o.write_shift(2, method);
          o.write_shift(4, 0);
          o.write_shift(-4, crcs[fcnt]);
          o.write_shift(4, outbuf.length);
          o.write_shift(4, fi.content.length);
          o.write_shift(2, namebuf.length);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(2, 0);
          o.write_shift(4, 0);
          o.write_shift(4, start);
          sz_cd += o.l;
          cdirs.push(o);
          sz_cd += namebuf.length;
          cdirs.push(namebuf);
          ++fcnt;
        }
        o = new_buf(22);
        o.write_shift(4, 101010256);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, fcnt);
        o.write_shift(2, fcnt);
        o.write_shift(4, sz_cd);
        o.write_shift(4, start_cd);
        o.write_shift(2, 0);
        return bconcat([bconcat(out), bconcat(cdirs), o]);
      }
      var ContentTypeMap = {
        "htm": "text/html",
        "xml": "text/xml",
        "gif": "image/gif",
        "jpg": "image/jpeg",
        "png": "image/png",
        "mso": "application/x-mso",
        "thmx": "application/vnd.ms-officetheme",
        "sh33tj5": "application/octet-stream"
      };
      function get_content_type(fi, fp) {
        if (fi.ctype)
          return fi.ctype;
        var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
        if (m && ContentTypeMap[m[1]])
          return ContentTypeMap[m[1]];
        if (fp) {
          m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
          if (m && ContentTypeMap[m[1]])
            return ContentTypeMap[m[1]];
        }
        return "application/octet-stream";
      }
      function write_base64_76(bstr) {
        var data = Base64_encode(bstr);
        var o = [];
        for (var i2 = 0; i2 < data.length; i2 += 76)
          o.push(data.slice(i2, i2 + 76));
        return o.join("\r\n") + "\r\n";
      }
      function write_quoted_printable(text) {
        var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
          var w = c.charCodeAt(0).toString(16).toUpperCase();
          return "=" + (w.length == 1 ? "0" + w : w);
        });
        encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
        if (encoded.charAt(0) == "\n")
          encoded = "=0D" + encoded.slice(1);
        encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
        var o = [], split = encoded.split("\r\n");
        for (var si = 0; si < split.length; ++si) {
          var str = split[si];
          if (str.length == 0) {
            o.push("");
            continue;
          }
          for (var i2 = 0; i2 < str.length; ) {
            var end = 76;
            var tmp = str.slice(i2, i2 + end);
            if (tmp.charAt(end - 1) == "=")
              end--;
            else if (tmp.charAt(end - 2) == "=")
              end -= 2;
            else if (tmp.charAt(end - 3) == "=")
              end -= 3;
            tmp = str.slice(i2, i2 + end);
            i2 += end;
            if (i2 < str.length)
              tmp += "=";
            o.push(tmp);
          }
        }
        return o.join("\r\n");
      }
      function parse_quoted_printable(data) {
        var o = [];
        for (var di = 0; di < data.length; ++di) {
          var line = data[di];
          while (di <= data.length && line.charAt(line.length - 1) == "=")
            line = line.slice(0, line.length - 1) + data[++di];
          o.push(line);
        }
        for (var oi = 0; oi < o.length; ++oi)
          o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
            return String.fromCharCode(parseInt($$.slice(1), 16));
          });
        return s2a(o.join("\r\n"));
      }
      function parse_mime(cfb, data, root) {
        var fname = "", cte = "", ctype = "", fdata;
        var di = 0;
        for (; di < 10; ++di) {
          var line = data[di];
          if (!line || line.match(/^\s*$/))
            break;
          var m = line.match(/^(.*?):\s*([^\s].*)$/);
          if (m)
            switch (m[1].toLowerCase()) {
              case "content-location":
                fname = m[2].trim();
                break;
              case "content-type":
                ctype = m[2].trim();
                break;
              case "content-transfer-encoding":
                cte = m[2].trim();
                break;
            }
        }
        ++di;
        switch (cte.toLowerCase()) {
          case "base64":
            fdata = s2a(Base64_decode(data.slice(di).join("")));
            break;
          case "quoted-printable":
            fdata = parse_quoted_printable(data.slice(di));
            break;
          default:
            throw new Error("Unsupported Content-Transfer-Encoding " + cte);
        }
        var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
        if (ctype)
          file.ctype = ctype;
      }
      function parse_mad(file, options) {
        if (a2s(file.slice(0, 13)).toLowerCase() != "mime-version:")
          throw new Error("Unsupported MAD header");
        var root = options && options.root || "";
        var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s(file)).split("\r\n");
        var di = 0, row = "";
        for (di = 0; di < data.length; ++di) {
          row = data[di];
          if (!/^Content-Location:/i.test(row))
            continue;
          row = row.slice(row.indexOf("file"));
          if (!root)
            root = row.slice(0, row.lastIndexOf("/") + 1);
          if (row.slice(0, root.length) == root)
            continue;
          while (root.length > 0) {
            root = root.slice(0, root.length - 1);
            root = root.slice(0, root.lastIndexOf("/") + 1);
            if (row.slice(0, root.length) == root)
              break;
          }
        }
        var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
        if (!mboundary)
          throw new Error("MAD cannot find boundary");
        var boundary = "--" + (mboundary[1] || "");
        var FileIndex = [], FullPaths = [];
        var o = {
          FileIndex,
          FullPaths
        };
        init_cfb(o);
        var start_di, fcnt = 0;
        for (di = 0; di < data.length; ++di) {
          var line = data[di];
          if (line !== boundary && line !== boundary + "--")
            continue;
          if (fcnt++)
            parse_mime(o, data.slice(start_di, di), root);
          start_di = di;
        }
        return o;
      }
      function write_mad(cfb, options) {
        var opts = options || {};
        var boundary = opts.boundary || "SheetJS";
        boundary = "------=" + boundary;
        var out = [
          "MIME-Version: 1.0",
          'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
          "",
          "",
          ""
        ];
        var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
        for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
          fp = cfb.FullPaths[i2].slice(root.length);
          fi = cfb.FileIndex[i2];
          if (!fi.size || !fi.content || fp == "Sh33tJ5")
            continue;
          fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
            return "_x" + c.charCodeAt(0).toString(16) + "_";
          }).replace(/[\u0080-\uFFFF]/g, function(u) {
            return "_u" + u.charCodeAt(0).toString(16) + "_";
          });
          var ca = fi.content;
          var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s(ca);
          var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
          for (var csl = 0; csl <= L; ++csl)
            if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
              ++dispcnt;
          var qp = dispcnt >= L * 4 / 5;
          out.push(boundary);
          out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
          out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
          out.push("Content-Type: " + get_content_type(fi, fp));
          out.push("");
          out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
        }
        out.push(boundary + "--\r\n");
        return out.join("\r\n");
      }
      function cfb_new(opts) {
        var o = {};
        init_cfb(o, opts);
        return o;
      }
      function cfb_add(cfb, name, content, opts) {
        var unsafe = opts && opts.unsafe;
        if (!unsafe)
          init_cfb(cfb);
        var file = !unsafe && CFB.find(cfb, name);
        if (!file) {
          var fpath = cfb.FullPaths[0];
          if (name.slice(0, fpath.length) == fpath)
            fpath = name;
          else {
            if (fpath.slice(-1) != "/")
              fpath += "/";
            fpath = (fpath + name).replace("//", "/");
          }
          file = { name: filename(name), type: 2 };
          cfb.FileIndex.push(file);
          cfb.FullPaths.push(fpath);
          if (!unsafe)
            CFB.utils.cfb_gc(cfb);
        }
        file.content = content;
        file.size = content ? content.length : 0;
        if (opts) {
          if (opts.CLSID)
            file.clsid = opts.CLSID;
          if (opts.mt)
            file.mt = opts.mt;
          if (opts.ct)
            file.ct = opts.ct;
        }
        return file;
      }
      function cfb_del(cfb, name) {
        init_cfb(cfb);
        var file = CFB.find(cfb, name);
        if (file) {
          for (var j = 0; j < cfb.FileIndex.length; ++j)
            if (cfb.FileIndex[j] == file) {
              cfb.FileIndex.splice(j, 1);
              cfb.FullPaths.splice(j, 1);
              return true;
            }
        }
        return false;
      }
      function cfb_mov(cfb, old_name, new_name) {
        init_cfb(cfb);
        var file = CFB.find(cfb, old_name);
        if (file) {
          for (var j = 0; j < cfb.FileIndex.length; ++j)
            if (cfb.FileIndex[j] == file) {
              cfb.FileIndex[j].name = filename(new_name);
              cfb.FullPaths[j] = new_name;
              return true;
            }
        }
        return false;
      }
      function cfb_gc(cfb) {
        rebuild_cfb(cfb, true);
      }
      exports2.find = find;
      exports2.read = read;
      exports2.parse = parse;
      exports2.write = write;
      exports2.writeFile = write_file;
      exports2.utils = {
        cfb_new,
        cfb_add,
        cfb_del,
        cfb_mov,
        cfb_gc,
        ReadShift,
        CheckField,
        prep_blob,
        bconcat,
        use_zlib,
        _deflateRaw: _deflate,
        _inflateRaw: _inflate,
        consts
      };
      return exports2;
    }();
    if (typeof __require !== "undefined" && typeof module !== "undefined" && typeof DO_NOT_EXPORT_CFB === "undefined") {
      module.exports = CFB;
    }
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require_stream().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream)
        Stream = function() {
        };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xlsx-populate/lib/XmlParser.js
var require_XmlParser = __commonJS({
  "node_modules/xlsx-populate/lib/XmlParser.js"(exports, module) {
    "use strict";
    var sax = require_sax();
    var externals = require_externals();
    var allWhitespaceRegex = /^\s+$/;
    var XmlParser = class {
      /**
       * Parse the XML text into a JSON object.
       * @param {string} xmlText - The XML text.
       * @returns {{}} The JSON object.
       */
      parseAsync(xmlText) {
        return new externals.Promise((resolve, reject) => {
          const parser = sax.parser(true);
          let parsed, current;
          const stack = [];
          parser.onerror = reject;
          parser.ontext = (text) => {
            if (allWhitespaceRegex.test(text)) {
              if (current && current.attributes["xml:space"] === "preserve") {
                current.children.push(text);
              }
            } else {
              current.children.push(this._covertToNumberIfNumber(text));
            }
          };
          parser.onopentagstart = (node) => {
            const child = { name: node.name, attributes: {}, children: [] };
            if (current) {
              current.children.push(child);
            } else {
              parsed = child;
            }
            stack.push(child);
            current = child;
          };
          parser.onclosetag = (node) => {
            stack.pop();
            current = stack[stack.length - 1];
          };
          parser.onattribute = (attribute) => {
            current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);
          };
          parser.onend = () => resolve(parsed);
          parser.write(xmlText).close();
        });
      }
      /**
       * Convert the string to a number if it looks like one.
       * @param {string} str - The string to convert.
       * @returns {string|number} The number if converted or the string if not.
       * @private
       */
      _covertToNumberIfNumber(str) {
        const num = Number(str);
        return num.toString() === str ? num : str;
      }
    };
    module.exports = XmlParser;
  }
});

// node_modules/xlsx-populate/lib/XmlBuilder.js
var require_XmlBuilder = __commonJS({
  "node_modules/xlsx-populate/lib/XmlBuilder.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var XML_DECLARATION = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`;
    var XmlBuilder = class {
      /**
       * Build an XML string from the JSON object.
       * @param {{}} node - The node.
       * @returns {string} The XML text.
       */
      build(node) {
        this._i = 0;
        const xml = this._build(node, "");
        if (xml === "")
          return;
        return XML_DECLARATION + xml;
      }
      /**
       * Build the XML string. (This is the internal recursive method.)
       * @param {{}} node - The node.
       * @param {string} xml - The initial XML doc string.
       * @returns {string} The generated XML element.
       * @private
       */
      _build(node, xml) {
        if (this._i++ % 1e6 === 0) {
          this._c = xml[0];
        }
        if (node && _.isFunction(node.toXml))
          node = node.toXml();
        if (_.isObject(node)) {
          if (!node.name)
            throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);
          xml += `<${node.name}`;
          _.forOwn(node.attributes, (value, name) => {
            xml += ` ${name}="${this._escapeString(value, true)}"`;
          });
          if (_.isEmpty(node.children)) {
            xml += "/>";
          } else {
            xml += ">";
            _.forEach(node.children, (child) => {
              xml = this._build(child, xml);
            });
            xml += `</${node.name}>`;
          }
        } else if (!_.isNil(node)) {
          xml += this._escapeString(node);
        }
        return xml;
      }
      /**
       * Escape a string for use in XML by replacing &, ", ', <, and >.
       * @param {*} value - The value to escape.
       * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.
       * @returns {string} The escaped string.
       * @private
       */
      _escapeString(value, isAttribute) {
        if (_.isNil(value))
          return value;
        value = value.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        if (isAttribute) {
          value = value.replace(/"/g, "&quot;");
        }
        return value;
      }
    };
    module.exports = XmlBuilder;
  }
});

// node_modules/xlsx-populate/lib/Encryptor.js
var require_Encryptor = __commonJS({
  "node_modules/xlsx-populate/lib/Encryptor.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var cfb = require_cfb();
    var crypto = require_crypto();
    var externals = require_externals();
    var XmlParser = require_XmlParser();
    var XmlBuilder = require_XmlBuilder();
    var xmlq = require_xmlq();
    var ENCRYPTION_INFO_PREFIX = Buffer.from([4, 0, 4, 0, 64, 0, 0, 0]);
    var PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;
    var PACKAGE_OFFSET = 8;
    var BLOCK_KEYS = {
      dataIntegrity: {
        hmacKey: Buffer.from([95, 178, 173, 1, 12, 185, 225, 246]),
        hmacValue: Buffer.from([160, 103, 127, 2, 178, 44, 132, 51])
      },
      key: Buffer.from([20, 110, 11, 231, 171, 172, 208, 214]),
      verifierHash: {
        input: Buffer.from([254, 167, 210, 118, 59, 75, 158, 121]),
        value: Buffer.from([215, 170, 15, 109, 48, 97, 52, 78])
      }
    };
    var Encryptor = class {
      /**
       * Encrypt the data with the password.
       * @param {Buffer} data - The data to encrypt
       * @param {string} password - The password
       * @returns {Buffer} The encrypted data
       */
      encrypt(data, password) {
        const packageKey = crypto.randomBytes(32);
        const encryptionInfo = {
          package: {
            // Info on the encryption of the package.
            cipherAlgorithm: "AES",
            // Cipher algorithm to use. Excel uses AES.
            cipherChaining: "ChainingModeCBC",
            // Cipher chaining mode to use. Excel uses CBC.
            saltValue: crypto.randomBytes(16),
            // Random value to use as encryption salt. Excel uses 16 bytes.
            hashAlgorithm: "SHA512",
            // Hash algorithm to use. Excel uses SHA512.
            hashSize: 64,
            // The size of the hash in bytes. SHA512 results in 64-byte hashes
            blockSize: 16,
            // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16
            keyBits: packageKey.length * 8
            // The number of bits in the package key.
          },
          key: {
            // Info on the encryption of the package key.
            cipherAlgorithm: "AES",
            // Cipher algorithm to use. Excel uses AES.
            cipherChaining: "ChainingModeCBC",
            // Cipher chaining mode to use. Excel uses CBC.
            saltValue: crypto.randomBytes(16),
            // Random value to use as encryption salt. Excel uses 16 bytes.
            hashAlgorithm: "SHA512",
            // Hash algorithm to use. Excel uses SHA512.
            hashSize: 64,
            // The size of the hash in bytes. SHA512 results in 64-byte hashes
            blockSize: 16,
            // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16
            spinCount: 1e5,
            // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.
            keyBits: 256
            // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.
          }
        };
        const encryptedPackage = this._cryptPackage(
          true,
          encryptionInfo.package.cipherAlgorithm,
          encryptionInfo.package.cipherChaining,
          encryptionInfo.package.hashAlgorithm,
          encryptionInfo.package.blockSize,
          encryptionInfo.package.saltValue,
          packageKey,
          data
        );
        const hmacKey = crypto.randomBytes(64);
        const hmacKeyIV = this._createIV(
          encryptionInfo.package.hashAlgorithm,
          encryptionInfo.package.saltValue,
          encryptionInfo.package.blockSize,
          BLOCK_KEYS.dataIntegrity.hmacKey
        );
        const encryptedHmacKey = this._crypt(
          true,
          encryptionInfo.package.cipherAlgorithm,
          encryptionInfo.package.cipherChaining,
          packageKey,
          hmacKeyIV,
          hmacKey
        );
        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);
        const hmacValueIV = this._createIV(
          encryptionInfo.package.hashAlgorithm,
          encryptionInfo.package.saltValue,
          encryptionInfo.package.blockSize,
          BLOCK_KEYS.dataIntegrity.hmacValue
        );
        const encryptedHmacValue = this._crypt(
          true,
          encryptionInfo.package.cipherAlgorithm,
          encryptionInfo.package.cipherChaining,
          packageKey,
          hmacValueIV,
          hmacValue
        );
        encryptionInfo.dataIntegrity = {
          encryptedHmacKey,
          encryptedHmacValue
        };
        const key = this._convertPasswordToKey(
          password,
          encryptionInfo.key.hashAlgorithm,
          encryptionInfo.key.saltValue,
          encryptionInfo.key.spinCount,
          encryptionInfo.key.keyBits,
          BLOCK_KEYS.key
        );
        encryptionInfo.key.encryptedKeyValue = this._crypt(
          true,
          encryptionInfo.key.cipherAlgorithm,
          encryptionInfo.key.cipherChaining,
          key,
          encryptionInfo.key.saltValue,
          packageKey
        );
        const verifierHashInput = crypto.randomBytes(16);
        const verifierHashInputKey = this._convertPasswordToKey(
          password,
          encryptionInfo.key.hashAlgorithm,
          encryptionInfo.key.saltValue,
          encryptionInfo.key.spinCount,
          encryptionInfo.key.keyBits,
          BLOCK_KEYS.verifierHash.input
        );
        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(
          true,
          encryptionInfo.key.cipherAlgorithm,
          encryptionInfo.key.cipherChaining,
          verifierHashInputKey,
          encryptionInfo.key.saltValue,
          verifierHashInput
        );
        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);
        const verifierHashValueKey = this._convertPasswordToKey(
          password,
          encryptionInfo.key.hashAlgorithm,
          encryptionInfo.key.saltValue,
          encryptionInfo.key.spinCount,
          encryptionInfo.key.keyBits,
          BLOCK_KEYS.verifierHash.value
        );
        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(
          true,
          encryptionInfo.key.cipherAlgorithm,
          encryptionInfo.key.cipherChaining,
          verifierHashValueKey,
          encryptionInfo.key.saltValue,
          verifierHashValue
        );
        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);
        let output = cfb.utils.cfb_new();
        cfb.utils.cfb_add(output, "EncryptionInfo", encryptionInfoBuffer);
        cfb.utils.cfb_add(output, "EncryptedPackage", encryptedPackage);
        cfb.utils.cfb_del(output, "Sh33tJ5");
        output = cfb.write(output);
        if (!Buffer.isBuffer(output))
          output = Buffer.from(output);
        return output;
      }
      /**
       * Decrypt the data with the given password
       * @param {Buffer} data - The data to decrypt
       * @param {string} password - The password
       * @returns {Promise.<Buffer>} The decrypted data
       */
      decryptAsync(data, password) {
        const parsed = cfb.parse(data);
        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: "EncryptionInfo" }).content;
        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: "EncryptedPackage" }).content;
        if (!Buffer.isBuffer(encryptionInfoBuffer))
          encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);
        if (!Buffer.isBuffer(encryptedPackageBuffer))
          encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);
        return externals.Promise.resolve().then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)).then((encryptionInfo) => {
          const key = this._convertPasswordToKey(
            password,
            encryptionInfo.key.hashAlgorithm,
            encryptionInfo.key.saltValue,
            encryptionInfo.key.spinCount,
            encryptionInfo.key.keyBits,
            BLOCK_KEYS.key
          );
          const packageKey = this._crypt(
            false,
            encryptionInfo.key.cipherAlgorithm,
            encryptionInfo.key.cipherChaining,
            key,
            encryptionInfo.key.saltValue,
            encryptionInfo.key.encryptedKeyValue
          );
          return this._cryptPackage(
            false,
            encryptionInfo.package.cipherAlgorithm,
            encryptionInfo.package.cipherChaining,
            encryptionInfo.package.hashAlgorithm,
            encryptionInfo.package.blockSize,
            encryptionInfo.package.saltValue,
            packageKey,
            encryptedPackageBuffer
          );
        });
      }
      /**
       * Build the encryption info XML/buffer
       * @param {{}} encryptionInfo - The encryption info object
       * @returns {Buffer} The buffer
       * @private
       */
      _buildEncryptionInfo(encryptionInfo) {
        const encryptionInfoNode = {
          name: "encryption",
          attributes: {
            xmlns: "http://schemas.microsoft.com/office/2006/encryption",
            "xmlns:p": "http://schemas.microsoft.com/office/2006/keyEncryptor/password",
            "xmlns:c": "http://schemas.microsoft.com/office/2006/keyEncryptor/certificate"
          },
          children: [
            {
              name: "keyData",
              attributes: {
                saltSize: encryptionInfo.package.saltValue.length,
                blockSize: encryptionInfo.package.blockSize,
                keyBits: encryptionInfo.package.keyBits,
                hashSize: encryptionInfo.package.hashSize,
                cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,
                cipherChaining: encryptionInfo.package.cipherChaining,
                hashAlgorithm: encryptionInfo.package.hashAlgorithm,
                saltValue: encryptionInfo.package.saltValue.toString("base64")
              }
            },
            {
              name: "dataIntegrity",
              attributes: {
                encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString("base64"),
                encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString("base64")
              }
            },
            {
              name: "keyEncryptors",
              children: [
                {
                  name: "keyEncryptor",
                  attributes: {
                    uri: "http://schemas.microsoft.com/office/2006/keyEncryptor/password"
                  },
                  children: [
                    {
                      name: "p:encryptedKey",
                      attributes: {
                        spinCount: encryptionInfo.key.spinCount,
                        saltSize: encryptionInfo.key.saltValue.length,
                        blockSize: encryptionInfo.key.blockSize,
                        keyBits: encryptionInfo.key.keyBits,
                        hashSize: encryptionInfo.key.hashSize,
                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,
                        cipherChaining: encryptionInfo.key.cipherChaining,
                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,
                        saltValue: encryptionInfo.key.saltValue.toString("base64"),
                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString("base64"),
                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString("base64"),
                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString("base64")
                      }
                    }
                  ]
                }
              ]
            }
          ]
        };
        const xmlBuilder = new XmlBuilder();
        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);
        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, "utf8")]);
      }
      /**
       * Parse the encryption info from the XML/buffer
       * @param {Buffer} buffer - The buffer
       * @returns {Promise.<{}>} The parsed encryption info object
       * @private
       */
      _parseEncryptionInfoAsync(buffer) {
        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString("utf8");
        const xmlParser = new XmlParser();
        return xmlParser.parseAsync(xml).then((doc) => {
          const keyDataNode = xmlq.findChild(doc, "keyData");
          const keyEncryptorsNode = xmlq.findChild(doc, "keyEncryptors");
          const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, "keyEncryptor");
          const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, "p:encryptedKey");
          return {
            package: {
              cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,
              cipherChaining: keyDataNode.attributes.cipherChaining,
              saltValue: Buffer.from(keyDataNode.attributes.saltValue, "base64"),
              hashAlgorithm: keyDataNode.attributes.hashAlgorithm,
              blockSize: keyDataNode.attributes.blockSize
            },
            key: {
              encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, "base64"),
              cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,
              cipherChaining: encryptedKeyNode.attributes.cipherChaining,
              saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, "base64"),
              hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,
              spinCount: encryptedKeyNode.attributes.spinCount,
              keyBits: encryptedKeyNode.attributes.keyBits
            }
          };
        });
      }
      /**
       * Calculate a hash of the concatenated buffers with the given algorithm.
       * @param {string} algorithm - The hash algorithm.
       * @param {Array.<Buffer>} buffers - The buffers to concat and hash
       * @returns {Buffer} The hash
       * @private
       */
      _hash(algorithm, ...buffers) {
        algorithm = algorithm.toLowerCase();
        const hashes = crypto.getHashes();
        if (hashes.indexOf(algorithm) < 0)
          throw new Error(`Hash algorithm '${algorithm}' not supported!`);
        const hash = crypto.createHash(algorithm);
        hash.update(Buffer.concat(buffers));
        return hash.digest();
      }
      /**
       * Calculate an HMAC of the concatenated buffers with the given algorithm and key
       * @param {string} algorithm - The algorithm.
       * @param {string} key - The key
       * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC
       * @returns {Buffer} The HMAC
       * @private
       */
      _hmac(algorithm, key, ...buffers) {
        algorithm = algorithm.toLowerCase();
        const hashes = crypto.getHashes();
        if (hashes.indexOf(algorithm) < 0)
          throw new Error(`HMAC algorithm '${algorithm}' not supported!`);
        const hmac = crypto.createHmac(algorithm, key);
        hmac.update(Buffer.concat(buffers));
        return hmac.digest();
      }
      /**
       * Encrypt/decrypt input
       * @param {boolean} encrypt - True to encrypt, false to decrypt
       * @param {string} cipherAlgorithm - The cipher algorithm
       * @param {sring} cipherChaining - The cipher chaining mode
       * @param {Buffer} key - The encryption key
       * @param {Buffer} iv - The initialization vector
       * @param {Buffer} input - The input
       * @returns {Buffer} The output
       * @private
       */
      _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {
        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;
        if (cipherChaining === "ChainingModeCBC")
          algorithm += "-cbc";
        else
          throw new Error(`Unknown cipher chaining: ${cipherChaining}`);
        const cipher = crypto[encrypt ? "createCipheriv" : "createDecipheriv"](algorithm, key, iv);
        cipher.setAutoPadding(false);
        let output = cipher.update(input);
        output = Buffer.concat([output, cipher.final()]);
        return output;
      }
      /**
       * Encrypt/decrypt the package
       * @param {boolean} encrypt - True to encrypt, false to decrypt
       * @param {string} cipherAlgorithm - The cipher algorithm
       * @param {string} cipherChaining - The cipher chaining mode
       * @param {string} hashAlgorithm - The hash algorithm
       * @param {number} blockSize - The IV block size
       * @param {Buffer} saltValue - The salt
       * @param {Buffer} key - The encryption key
       * @param {Buffer} input - The package input
       * @returns {Buffer} The output
       * @private
       */
      _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {
        const outputChunks = [];
        const offset = encrypt ? 0 : PACKAGE_OFFSET;
        let i = 0, start = 0, end = 0;
        while (end < input.length) {
          start = end;
          end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;
          if (end > input.length)
            end = input.length;
          let inputChunk = input.slice(start + offset, end + offset);
          const remainder = inputChunk.length % blockSize;
          if (remainder)
            inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);
          const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);
          const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);
          outputChunks.push(outputChunk);
          i++;
        }
        let output = Buffer.concat(outputChunks);
        if (encrypt) {
          output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);
        } else {
          const length = input.readUInt32LE(0);
          output = output.slice(0, length);
        }
        return output;
      }
      /**
       * Create a buffer of an integer encoded as a uint32le
       * @param {number} value - The integer to encode
       * @param {number} [bufferSize=4] The output buffer size in bytes
       * @returns {Buffer} The buffer
       * @private
       */
      _createUInt32LEBuffer(value, bufferSize = 4) {
        const buffer = Buffer.alloc(bufferSize);
        buffer.writeUInt32LE(value, 0);
        return buffer;
      }
      /**
       * Convert a password into an encryption key
       * @param {string} password - The password
       * @param {string} hashAlgorithm - The hash algoritm
       * @param {Buffer} saltValue - The salt value
       * @param {number} spinCount - The spin count
       * @param {number} keyBits - The length of the key in bits
       * @param {Buffer} blockKey - The block key
       * @returns {Buffer} The encryption key
       * @private
       */
      _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {
        const passwordBuffer = Buffer.from(password, "utf16le");
        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);
        for (let i = 0; i < spinCount; i++) {
          const iterator = this._createUInt32LEBuffer(i);
          key = this._hash(hashAlgorithm, iterator, key);
        }
        key = this._hash(hashAlgorithm, key, blockKey);
        const keyBytes = keyBits / 8;
        if (key.length < keyBytes) {
          const tmp = Buffer.alloc(keyBytes, 54);
          key.copy(tmp);
          key = tmp;
        } else if (key.length > keyBytes) {
          key = key.slice(0, keyBytes);
        }
        return key;
      }
      /**
       * Create an initialization vector (IV)
       * @param {string} hashAlgorithm - The hash algorithm
       * @param {Buffer} saltValue - The salt value
       * @param {number} blockSize - The size of the IV
       * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer
       * @returns {Buffer} The IV
       * @private
       */
      _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {
        if (typeof blockKey === "number")
          blockKey = this._createUInt32LEBuffer(blockKey);
        let iv = this._hash(hashAlgorithm, saltValue, blockKey);
        if (iv.length < blockSize) {
          const tmp = Buffer.alloc(blockSize, 54);
          iv.copy(tmp);
          iv = tmp;
        } else if (iv.length > blockSize) {
          iv = iv.slice(0, blockSize);
        }
        return iv;
      }
    };
    module.exports = Encryptor;
  }
});

// node_modules/xlsx-populate/lib/Workbook.js
var require_Workbook = __commonJS({
  "node_modules/xlsx-populate/lib/Workbook.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var fs = require_fs();
    var JSZip = require_jszip_min();
    var externals = require_externals();
    var regexify = require_regexify();
    var blank = require_blank()();
    var xmlq = require_xmlq();
    var Sheet = require_Sheet();
    var ContentTypes = require_ContentTypes();
    var AppProperties = require_AppProperties();
    var CoreProperties = require_CoreProperties();
    var Relationships = require_Relationships();
    var SharedStrings = require_SharedStrings();
    var StyleSheet = require_StyleSheet();
    var Encryptor = require_Encryptor();
    var XmlParser = require_XmlParser();
    var XmlBuilder = require_XmlBuilder();
    var ArgHandler = require_ArgHandler();
    var addressConverter = require_addressConverter();
    var zipFileOpts = {
      date: /* @__PURE__ */ new Date(0),
      createFolders: false
    };
    var xmlParser = new XmlParser();
    var xmlBuilder = new XmlBuilder();
    var encryptor = typeof Encryptor === "function" && new Encryptor();
    var badSheetNameChars = ["\\", "/", "*", "[", "]", ":", "?"];
    var maxSheetNameLength = 31;
    var nodeOrder = [
      "fileVersion",
      "fileSharing",
      "workbookPr",
      "workbookProtection",
      "bookViews",
      "sheets",
      "functionGroups",
      "externalReferences",
      "definedNames",
      "calcPr",
      "oleSize",
      "customWorkbookViews",
      "pivotCaches",
      "smartTagPr",
      "smartTagTypes",
      "webPublishing",
      "fileRecoveryPr",
      "webPublishObjects",
      "extLst"
    ];
    var Workbook = class _Workbook {
      /**
       * Create a new blank workbook.
       * @returns {Promise.<Workbook>} The workbook.
       * @ignore
       */
      static fromBlankAsync() {
        return _Workbook.fromDataAsync(blank);
      }
      /**
       * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)
       * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.
       * @param {{}} [opts] - Options
       * @returns {Promise.<Workbook>} The workbook.
       * @ignore
       */
      static fromDataAsync(data, opts) {
        return new _Workbook()._initAsync(data, opts);
      }
      /**
       * Loads a workbook from file.
       * @param {string} path - The path to the workbook.
       * @param {{}} [opts] - Options
       * @returns {Promise.<Workbook>} The workbook.
       * @ignore
       */
      static fromFileAsync(path, opts) {
        if (process.browser)
          throw new Error("Workbook.fromFileAsync is not supported in the browser");
        return new externals.Promise((resolve, reject) => {
          fs.readFile(path, (err, data) => {
            if (err)
              return reject(err);
            resolve(data);
          });
        }).then((data) => _Workbook.fromDataAsync(data, opts));
      }
      /**
       * Get the active sheet in the workbook.
       * @returns {Sheet} The active sheet.
       */
      /**
      * Set the active sheet in the workbook.
      * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.
      * @returns {Workbook} The workbook.
      */
      activeSheet() {
        return new ArgHandler("Workbook.activeSheet").case(() => {
          return this._activeSheet;
        }).case("*", (sheet) => {
          if (!(sheet instanceof Sheet))
            sheet = this.sheet(sheet);
          if (sheet.hidden())
            throw new Error("You may not activate a hidden sheet.");
          _.forEach(this._sheets, (current) => {
            current.tabSelected(current === sheet);
          });
          this._activeSheet = sheet;
          return this;
        }).handle(arguments);
      }
      /**
       * Add a new sheet to the workbook.
       * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
       * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
       * @returns {Sheet} The new sheet.
       */
      addSheet(name, indexOrBeforeSheet) {
        return this._addSheet(name, indexOrBeforeSheet);
      }
      /**
       * Gets a defined name scoped to the workbook.
       * @param {string} name - The defined name.
       * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.
       */
      /**
      * Set a defined name scoped to the workbook.
      * @param {string} name - The defined name.
      * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.
      * @returns {Workbook} The workbook.
      */
      definedName() {
        return new ArgHandler("Workbook.definedName").case("string", (name) => {
          return this.scopedDefinedName(void 0, name);
        }).case(["string", "*"], (name, refersTo) => {
          this.scopedDefinedName(void 0, name, refersTo);
          return this;
        }).handle(arguments);
      }
      /**
       * Delete a sheet from the workbook.
       * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.
       * @returns {Workbook} The workbook.
       */
      deleteSheet(sheet) {
        if (!(sheet instanceof Sheet)) {
          sheet = this.sheet(sheet);
          if (!sheet)
            throw new Error("Invalid move sheet reference.");
        }
        const visibleSheets = _.filter(this._sheets, (sheet2) => !sheet2.hidden());
        if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {
          throw new Error("This sheet may not be deleted as a workbook must contain at least one visible sheet.");
        }
        let index = this._sheets.indexOf(sheet);
        this._sheets.splice(index, 1);
        if (sheet === this.activeSheet()) {
          if (index >= this._sheets.length)
            index--;
          this.activeSheet(index);
        }
        return this;
      }
      /**
       * Find the given pattern in the workbook and optionally replace it.
       * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.
       * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.
       * @returns {boolean} A flag indicating if the pattern was found.
       */
      find(pattern, replacement) {
        pattern = regexify(pattern);
        let matches = [];
        this._sheets.forEach((sheet) => {
          matches = matches.concat(sheet.find(pattern, replacement));
        });
        return matches;
      }
      /**
       * Move a sheet to a new position.
       * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.
       * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
       * @returns {Workbook} The workbook.
       */
      moveSheet(sheet, indexOrBeforeSheet) {
        if (!(sheet instanceof Sheet)) {
          sheet = this.sheet(sheet);
          if (!sheet)
            throw new Error("Invalid move sheet reference.");
        }
        const from = this._sheets.indexOf(sheet);
        let to;
        if (_.isNil(indexOrBeforeSheet)) {
          to = this._sheets.length - 1;
        } else if (_.isInteger(indexOrBeforeSheet)) {
          to = indexOrBeforeSheet;
        } else {
          if (!(indexOrBeforeSheet instanceof Sheet)) {
            indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);
            if (!indexOrBeforeSheet)
              throw new Error("Invalid before sheet reference.");
          }
          to = this._sheets.indexOf(indexOrBeforeSheet);
        }
        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);
        return this;
      }
      /**
       * Generates the workbook output.
       * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.
       * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.
       */
      /**
      * Generates the workbook output.
      * @param {{}} [opts] Options
      * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.
      * @param {string} [opts.password] - The password to use to encrypt the workbook.
      * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.
      */
      outputAsync(opts) {
        opts = opts || {};
        if (typeof opts === "string")
          opts = { type: opts };
        this._setSheetRefs();
        let definedNamesNode = xmlq.findChild(this._node, "definedNames");
        this._sheets.forEach((sheet, i) => {
          if (!sheet._autoFilter)
            return;
          if (!definedNamesNode) {
            definedNamesNode = {
              name: "definedNames",
              attributes: {},
              children: []
            };
            xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);
          }
          xmlq.appendChild(definedNamesNode, {
            name: "definedName",
            attributes: {
              name: "_xlnm._FilterDatabase",
              localSheetId: i,
              hidden: "1"
            },
            children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]
          });
        });
        this._sheetsNode.children = [];
        this._sheets.forEach((sheet, i) => {
          const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;
          const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;
          const sheetXmls = sheet.toXmls();
          const relationship = this._relationships.findById(sheetXmls.id.attributes["r:id"]);
          relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;
          this._sheetsNode.children.push(sheetXmls.id);
          this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);
          const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);
          if (relationshipsXml) {
            this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);
          } else {
            this._zip.remove(sheetRelsPath);
          }
        });
        this._zip.file("[Content_Types].xml", xmlBuilder.build(this._contentTypes), zipFileOpts);
        this._zip.file("docProps/app.xml", xmlBuilder.build(this._appProperties), zipFileOpts);
        this._zip.file("docProps/core.xml", xmlBuilder.build(this._coreProperties), zipFileOpts);
        this._zip.file("xl/_rels/workbook.xml.rels", xmlBuilder.build(this._relationships), zipFileOpts);
        this._zip.file("xl/sharedStrings.xml", xmlBuilder.build(this._sharedStrings), zipFileOpts);
        this._zip.file("xl/styles.xml", xmlBuilder.build(this._styleSheet), zipFileOpts);
        this._zip.file("xl/workbook.xml", xmlBuilder.build(this._node), zipFileOpts);
        return this._zip.generateAsync({
          type: "nodebuffer",
          compression: "DEFLATE"
        }).then((output) => {
          if (opts.password)
            output = encryptor.encrypt(output, opts.password);
          return this._convertBufferToOutput(output, opts.type);
        });
      }
      /**
       * Gets the sheet with the provided name or index (0-based).
       * @param {string|number} sheetNameOrIndex - The sheet name or index.
       * @returns {Sheet|undefined} The sheet or undefined if not found.
       */
      sheet(sheetNameOrIndex) {
        if (_.isInteger(sheetNameOrIndex))
          return this._sheets[sheetNameOrIndex];
        return _.find(this._sheets, (sheet) => sheet.name() === sheetNameOrIndex);
      }
      /**
       * Get an array of all the sheets in the workbook.
       * @returns {Array.<Sheet>} The sheets.
       */
      sheets() {
        return this._sheets.slice();
      }
      /**
       * Gets an individual property.
       * @param {string} name - The name of the property.
       * @returns {*} The property.
       */
      /**
      * Gets multiple properties.
      * @param {Array.<string>} names - The names of the properties.
      * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.
      */
      /**
      * Sets an individual property.
      * @param {string} name - The name of the property.
      * @param {*} value - The value to set.
      * @returns {Workbook} The workbook.
      */
      /**
      * Sets multiple properties.
      * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.
      * @returns {Workbook} The workbook.
      */
      property() {
        return new ArgHandler("Workbook.property").case("string", (name) => {
          return this._coreProperties.get(name);
        }).case("array", (names) => {
          const values = {};
          names.forEach((name) => {
            values[name] = this._coreProperties.get(name);
          });
          return values;
        }).case(["string", "*"], (name, value) => {
          this._coreProperties.set(name, value);
          return this;
        }).case("object", (nameValues) => {
          for (const name in nameValues) {
            if (!nameValues.hasOwnProperty(name))
              continue;
            const value = nameValues[name];
            this._coreProperties.set(name, value);
          }
          return this;
        }).handle(arguments);
      }
      /**
       * Get access to core properties object
       * @returns {CoreProperties} The core properties.
       */
      properties() {
        return this._coreProperties;
      }
      /**
       * Write the workbook to file. (Not supported in browsers.)
       * @param {string} path - The path of the file to write.
       * @param {{}} [opts] - Options
       * @param {string} [opts.password] - The password to encrypt the workbook.
       * @returns {Promise.<undefined>} A promise.
       */
      toFileAsync(path, opts) {
        if (process.browser)
          throw new Error("Workbook.toFileAsync is not supported in the browser.");
        return this.outputAsync(opts).then((data) => new externals.Promise((resolve, reject) => {
          fs.writeFile(path, data, (err) => {
            if (err)
              return reject(err);
            resolve();
          });
        }));
      }
      /**
       * Gets a scoped defined name.
       * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.
       * @param {string} name - The defined name.
       * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.
       * @ignore
       */
      /**
      * Sets a scoped defined name.
      * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.
      * @param {string} name - The defined name.
      * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.
      * @returns {Workbook} The workbook.
      * @ignore
      */
      scopedDefinedName(sheetScope, name, refersTo) {
        let definedNamesNode = xmlq.findChild(this._node, "definedNames");
        let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, (node) => node.attributes.name === name && node.localSheet === sheetScope);
        return new ArgHandler("Workbook.scopedDefinedName").case(["*", "string"], () => {
          const refersTo2 = definedNameNode && definedNameNode.children[0];
          if (!refersTo2)
            return void 0;
          const ref = addressConverter.fromAddress(refersTo2);
          if (!ref)
            return refersTo2;
          const sheet = this.sheet(ref.sheetName);
          if (ref.type === "cell")
            return sheet.cell(ref.rowNumber, ref.columnNumber);
          if (ref.type === "range")
            return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);
          if (ref.type === "row")
            return sheet.row(ref.rowNumber);
          if (ref.type === "column")
            return sheet.column(ref.columnNumber);
          return refersTo2;
        }).case(["*", "string", "nil"], () => {
          if (definedNameNode)
            xmlq.removeChild(definedNamesNode, definedNameNode);
          if (definedNamesNode && !definedNamesNode.children.length)
            xmlq.removeChild(this._node, definedNamesNode);
          return this;
        }).case(["*", "string", "*"], () => {
          if (typeof refersTo !== "string") {
            refersTo = refersTo.address({
              includeSheetName: true,
              anchored: true
            });
          }
          if (!definedNamesNode) {
            definedNamesNode = {
              name: "definedNames",
              attributes: {},
              children: []
            };
            xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);
          }
          if (!definedNameNode) {
            definedNameNode = {
              name: "definedName",
              attributes: { name },
              children: [refersTo]
            };
            if (sheetScope)
              definedNameNode.localSheet = sheetScope;
            xmlq.appendChild(definedNamesNode, definedNameNode);
          }
          definedNameNode.children = [refersTo];
          return this;
        }).handle(arguments);
      }
      /**
       * Get the shared strings table.
       * @returns {SharedStrings} The shared strings table.
       * @ignore
       */
      sharedStrings() {
        return this._sharedStrings;
      }
      /**
       * Get the style sheet.
       * @returns {StyleSheet} The style sheet.
       * @ignore
       */
      styleSheet() {
        return this._styleSheet;
      }
      /**
       * Add a new sheet to the workbook.
       * 
       * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.
       * @param {Sheet} from - The sheet to be cloned.
       * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
       * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
       * @returns {Sheet} The new sheet.
       */
      cloneSheet(from, name, indexOrBeforeSheet) {
        if (!from || !(from instanceof Sheet))
          throw new Error("Invalid clone from.");
        return this._addSheet(name, indexOrBeforeSheet, () => {
          const cloneXml = (node) => {
            if (node && _.isFunction(node.toXml))
              node = node.toXml();
            if (typeof node === "object") {
              if (node.name) {
                const result = {
                  name: node.name,
                  attributes: {},
                  children: []
                };
                _.forOwn(node.attributes, (value, name2) => {
                  result.attributes[name2] = value;
                });
                let chld;
                if (node.children) {
                  node.children.forEach((child) => {
                    chld = cloneXml(child);
                    if (child !== null) {
                      result.children.push(chld);
                    }
                  });
                }
                return result;
              }
            } else if (node !== null) {
              return node;
            }
            return null;
          };
          const fromXml = from.toXmls();
          const sheetNode = cloneXml(fromXml.sheet);
          const relationshipNode = cloneXml(fromXml.relationships);
          return { sheetNode, relationshipNode };
        });
      }
      /**
       * Add a new sheet to the workbook.
       * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
       * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
       * @param {callback} [getTemplateNodes] optional callback function for template nodes
       * @returns {Sheet} The new sheet.
       * @private
       */
      _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {
        if (!name || typeof name !== "string")
          throw new Error("Invalid sheet name.");
        if (_.some(badSheetNameChars, (char) => name.indexOf(char) >= 0))
          throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(" ")}`);
        if (name.length > maxSheetNameLength)
          throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);
        if (this.sheet(name))
          throw new Error(`Sheet with name "${name}" already exists.`);
        let index;
        if (_.isNil(indexOrBeforeSheet)) {
          index = this._sheets.length;
        } else if (_.isInteger(indexOrBeforeSheet)) {
          index = indexOrBeforeSheet;
        } else {
          if (!(indexOrBeforeSheet instanceof Sheet)) {
            indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);
            if (!indexOrBeforeSheet)
              throw new Error("Invalid before sheet reference.");
          }
          index = this._sheets.indexOf(indexOrBeforeSheet);
        }
        const relationship = this._relationships.add("worksheet");
        const sheetIdNode = {
          name: "sheet",
          attributes: {
            name,
            sheetId: ++this._maxSheetId,
            "r:id": relationship.attributes.Id
          },
          children: []
        };
        let sheet;
        if (getTemplateNodes) {
          const { sheetNode, relationshipNode } = getTemplateNodes();
          sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);
        } else {
          sheet = new Sheet(this, sheetIdNode);
        }
        this._sheets.splice(index, 0, sheet);
        return sheet;
      }
      /**
       * Initialize the workbook. (This is separated from the constructor to ease testing.)
       * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.
       * @param {{}} [opts] - Options
       * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.
       * @returns {Promise.<Workbook>} The workbook.
       * @private
       */
      _initAsync(data, opts) {
        opts = opts || {};
        this._maxSheetId = 0;
        this._sheets = [];
        return externals.Promise.resolve().then(() => {
          return this._convertInputToBufferAsync(data, opts.base64).then((buffer) => {
            data = buffer;
          });
        }).then(() => {
          if (!opts.password)
            return;
          return encryptor.decryptAsync(data, opts.password).then((decrypted) => {
            data = decrypted;
          });
        }).then(() => JSZip.loadAsync(data)).then((zip) => {
          this._zip = zip;
          return this._parseNodesAsync([
            "[Content_Types].xml",
            "docProps/app.xml",
            "docProps/core.xml",
            "xl/_rels/workbook.xml.rels",
            "xl/sharedStrings.xml",
            "xl/styles.xml",
            "xl/workbook.xml"
          ]);
        }).then((nodes) => {
          const contentTypesNode = nodes[0];
          const appPropertiesNode = nodes[1];
          const corePropertiesNode = nodes[2];
          const relationshipsNode = nodes[3];
          const sharedStringsNode = nodes[4];
          const styleSheetNode = nodes[5];
          const workbookNode = nodes[6];
          this._contentTypes = new ContentTypes(contentTypesNode);
          this._appProperties = new AppProperties(appPropertiesNode);
          this._coreProperties = new CoreProperties(corePropertiesNode);
          this._relationships = new Relationships(relationshipsNode);
          this._sharedStrings = new SharedStrings(sharedStringsNode);
          this._styleSheet = new StyleSheet(styleSheetNode);
          this._node = workbookNode;
          if (!this._relationships.findByType("sharedStrings")) {
            this._relationships.add("sharedStrings", "sharedStrings.xml");
          }
          if (!this._contentTypes.findByPartName("/xl/sharedStrings.xml")) {
            this._contentTypes.add("/xl/sharedStrings.xml", "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml");
          }
          this._zip.remove("xl/calcChain.xml");
          this._sheetsNode = xmlq.findChild(this._node, "sheets");
          return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {
            if (sheetIdNode.attributes.sheetId > this._maxSheetId)
              this._maxSheetId = sheetIdNode.attributes.sheetId;
            return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`]).then((nodes2) => {
              const sheetNode = nodes2[0];
              const sheetRelationshipsNode = nodes2[1];
              this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);
            });
          }));
        }).then(() => this._parseSheetRefs()).then(() => this);
      }
      /**
       * Parse files out of zip into XML node objects.
       * @param {Array.<string>} names - The file names to parse.
       * @returns {Promise.<Array.<{}>>} An array of the parsed objects.
       * @private
       */
      _parseNodesAsync(names) {
        return externals.Promise.all(_.map(names, (name) => this._zip.file(name))).then((files) => externals.Promise.all(_.map(files, (file) => file && file.async("string")))).then((texts) => externals.Promise.all(_.map(texts, (text) => text && xmlParser.parseAsync(text))));
      }
      /**
       * Parse the sheet references out so we can reorder freely.
       * @returns {undefined}
       * @private
       */
      _parseSheetRefs() {
        const bookViewsNode = xmlq.findChild(this._node, "bookViews");
        const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, "workbookView");
        const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;
        this._activeSheet = this._sheets[activeTabId];
        const definedNamesNode = xmlq.findChild(this._node, "definedNames");
        if (definedNamesNode) {
          _.forEach(definedNamesNode.children, (definedNameNode) => {
            if (definedNameNode.attributes.hasOwnProperty("localSheetId")) {
              definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];
            }
          });
        }
      }
      /**
       * Set the proper sheet references in the XML.
       * @returns {undefined}
       * @private
       */
      _setSheetRefs() {
        let bookViewsNode = xmlq.findChild(this._node, "bookViews");
        if (!bookViewsNode) {
          bookViewsNode = { name: "bookViews", attributes: {}, children: [] };
          xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);
        }
        let workbookViewNode = xmlq.findChild(bookViewsNode, "workbookView");
        if (!workbookViewNode) {
          workbookViewNode = { name: "workbookView", attributes: {}, children: [] };
          xmlq.appendChild(bookViewsNode, workbookViewNode);
        }
        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);
        const definedNamesNode = xmlq.findChild(this._node, "definedNames");
        if (definedNamesNode) {
          _.forEach(definedNamesNode.children, (definedNameNode) => {
            if (definedNameNode.localSheet) {
              definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);
            }
          });
        }
      }
      /**
       * Convert buffer to desired output format
       * @param {Buffer} buffer - The buffer
       * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer
       * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output
       * @private
       */
      _convertBufferToOutput(buffer, type) {
        if (!type)
          type = process.browser ? "blob" : "nodebuffer";
        if (type === "buffer" || type === "nodebuffer")
          return buffer;
        if (process.browser && type === "blob")
          return new Blob([buffer], { type: _Workbook.MIME_TYPE });
        if (type === "base64")
          return buffer.toString("base64");
        if (type === "binarystring")
          return buffer.toString("utf8");
        if (type === "uint8array")
          return new Uint8Array(buffer);
        if (type === "arraybuffer")
          return new Uint8Array(buffer).buffer;
        throw new Error(`Output type '${type}' not supported.`);
      }
      /**
       * Convert input to buffer
       * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input
       * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary
       * @returns {Promise.<Buffer>} The buffer.
       * @private
       */
      _convertInputToBufferAsync(input, base64) {
        return externals.Promise.resolve().then(() => {
          if (Buffer.isBuffer(input))
            return input;
          if (process.browser && input instanceof Blob) {
            return new externals.Promise((resolve) => {
              const fileReader = new FileReader();
              fileReader.onload = (event) => {
                resolve(Buffer.from(event.target.result));
              };
              fileReader.readAsArrayBuffer(input);
            });
          }
          if (typeof input === "string" && base64)
            return Buffer.from(input, "base64");
          if (typeof input === "string" && !base64)
            return Buffer.from(input, "utf8");
          if (input instanceof Uint8Array || input instanceof ArrayBuffer)
            return Buffer.from(input);
          throw new Error(`Input type unknown.`);
        });
      }
    };
    Workbook.MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    module.exports = Workbook;
  }
});

// node_modules/xlsx-populate/lib/XlsxPopulate.js
var require_XlsxPopulate = __commonJS({
  "node_modules/xlsx-populate/lib/XlsxPopulate.js"(exports, module) {
    var externals = require_externals();
    var Workbook = require_Workbook();
    var FormulaError = require_FormulaError();
    var dateConverter = require_dateConverter();
    var RichText = require_RichText();
    var XlsxPopulate = class {
      /**
       * Convert a date to a number for Excel.
       * @param {Date} date - The date.
       * @returns {number} The number.
       */
      static dateToNumber(date) {
        return dateConverter.dateToNumber(date);
      }
      /**
       * Create a new blank workbook.
       * @returns {Promise.<Workbook>} The workbook.
       */
      static fromBlankAsync() {
        return Workbook.fromBlankAsync();
      }
      /**
       * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)
       * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.
       * @param {{}} [opts] - Options
       * @param {string} [opts.password] - The password to decrypt the workbook.
       * @returns {Promise.<Workbook>} The workbook.
       */
      static fromDataAsync(data, opts) {
        return Workbook.fromDataAsync(data, opts);
      }
      /**
       * Loads a workbook from file.
       * @param {string} path - The path to the workbook.
       * @param {{}} [opts] - Options
       * @param {string} [opts.password] - The password to decrypt the workbook.
       * @returns {Promise.<Workbook>} The workbook.
       */
      static fromFileAsync(path, opts) {
        return Workbook.fromFileAsync(path, opts);
      }
      /**
       * Convert an Excel number to a date.
       * @param {number} number - The number.
       * @returns {Date} The date.
       */
      static numberToDate(number) {
        return dateConverter.numberToDate(number);
      }
      /**
       * The Promise library.
       * @type {Promise}
       */
      static get Promise() {
        return externals.Promise;
      }
      static set Promise(Promise2) {
        externals.Promise = Promise2;
      }
    };
    XlsxPopulate.MIME_TYPE = Workbook.MIME_TYPE;
    XlsxPopulate.FormulaError = FormulaError;
    XlsxPopulate.RichText = RichText;
    module.exports = XlsxPopulate;
  }
});
export default require_XlsxPopulate();
/*! Bundled license information:

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

cfb/cfb.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
//# sourceMappingURL=xlsx-populate.js.map
